Ext.data.JsonP.CLI_Mixin({"tagname":"class","name":"CLI.Mixin","autodetected":{},"files":[{"filename":"Mixin.js","href":"Mixin.html#CLI-Mixin"}],"protected":true,"members":[],"alternateClassNames":[],"aliases":{},"id":"class-CLI.Mixin","short_doc":"This class is a base class for mixins. ...","component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/Mixin.html#CLI-Mixin' target='_blank'>Mixin.js</a></div></pre><div class='doc-contents'><p>This class is a base class for mixins. These are classes that extend this class and are\ndesigned to be used as a <code>mixin</code> by user code.</p>\n\n<p>It provides mixins with the ability to \"hook\" class methods of the classes in to which\nthey are mixed. For example, consider the <code>destroy</code> method pattern. If a mixin class\nhad cleanup requirements, it would need to be called as part of <code>destroy</code>.</p>\n\n<p>Starting with a basic class we might have:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Base', {\n     destroy: function () {\n         console.log('B');\n         // cleanup\n     }\n });\n</code></pre>\n\n<p>A derived class would look like this:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     destroy: function () {\n         console.log('D');\n         // more cleanup\n\n         this.callParent(); // let Foo.bar.Base cleanup as well\n     }\n });\n</code></pre>\n\n<p>To see how using this class help, start with a \"normal\" mixin class that also needs to\ncleanup its resources. These mixins must be called explicitly by the classes that use\nthem. For example:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     destroy: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n         // more cleanup\n\n         this.mixins.util.destroy.call(this);\n\n         this.callParent(); // let Foo.bar.Base cleanup as well\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs D then U then B\n</code></pre>\n\n<p>This class is designed to solve the above in simpler and more reliable way.</p>\n\n<h2>mixinConfig</h2>\n\n<p>Using <code>mixinConfig</code> the mixin class can provide \"before\" or \"after\" hooks that do not\ninvolve the derived class implementation. This also means the derived class cannot\nadjust parameters to the hook methods.</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     extend: '<a href=\"#!/api/CLI.Mixin\" rel=\"CLI.Mixin\" class=\"docClass\">CLI.Mixin</a>',\n\n     mixinConfig: {\n         after: {\n             destroy: 'destroyUtil'\n         }\n     },\n\n     destroyUtil: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Class', {\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs D then U\n</code></pre>\n\n<p> If the destruction should occur in the other order, you can use <code>before</code>:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     extend: '<a href=\"#!/api/CLI.Mixin\" rel=\"CLI.Mixin\" class=\"docClass\">CLI.Mixin</a>',\n\n     mixinConfig: {\n         before: {\n             destroy: 'destroyUtil'\n         }\n     },\n\n     destroyUtil: function () {\n         console.log('U');\n     }\n });\n\n <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Class', {\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs U then D\n</code></pre>\n\n<h3>Chaining</h3>\n\n<p>One way for a mixin to provide methods that act more like normal inherited methods is\nto use an <code>on</code> declaration. These methods will be injected into the <code>callParent</code> chain\nbetween the derived and superclass. For example:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     extend: '<a href=\"#!/api/CLI.Mixin\" rel=\"CLI.Mixin\" class=\"docClass\">CLI.Mixin</a>',\n\n     mixinConfig: {\n         on: {\n             destroy: function () {\n                 console.log('M');\n             }\n         }\n     }\n });\n\n <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Base', {\n     destroy: function () {\n         console.log('B');\n     }\n });\n\n <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Derived', {\n     extend: 'Foo.bar.Base',\n\n     mixins: {\n         util: 'Foo.bar.Util'\n     },\n\n     destroy: function () {\n         this.callParent();\n         console.log('D');\n     }\n });\n\n var obj = new Foo.bar.Derived();\n\n obj.destroy();\n // logs M then B then D\n</code></pre>\n\n<p>As with <code>before</code> and <code>after</code>, the value of <code>on</code> can be a method name.</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     extend: '<a href=\"#!/api/CLI.Mixin\" rel=\"CLI.Mixin\" class=\"docClass\">CLI.Mixin</a>',\n\n     mixinConfig: {\n         on: {\n             destroy: 'onDestroy'\n         }\n     }\n\n     onDestroy: function () {\n         console.log('M');\n     }\n });\n</code></pre>\n\n<p>Because this technique leverages <code>callParent</code>, the derived class controls the time and\nparameters for the call to all of its bases (be they <code>extend</code> or <code>mixin</code> flavor).</p>\n\n<h3>Derivations</h3>\n\n<p>Some mixins need to process class extensions of their target class. To do this you can\ndefine an <code>extended</code> method like so:</p>\n\n<pre><code> <a href=\"#!/api/CLI-method-define\" rel=\"CLI-method-define\" class=\"docClass\">CLI.define</a>('Foo.bar.Util', {\n     extend: '<a href=\"#!/api/CLI.Mixin\" rel=\"CLI.Mixin\" class=\"docClass\">CLI.Mixin</a>',\n\n     mixinConfig: {\n         extended: function (baseClass, derivedClass, classBody) {\n             // This function is called whenever a new \"derivedClass\" is created\n             // that extends a \"baseClass\" in to which this mixin was mixed.\n         }\n     }\n });\n</code></pre>\n</div><div class='members'></div></div>","meta":{"protected":true}});