<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * This file is part of CLI Framework
 */

<span id='CLI-Loader'>/**
</span> * @class CLI.Loader
 *
 * CLI.Loader is the heart of the new dynamic dependency loading capability in CLI Framework. It is most commonly used
 * via the {@link CLI#require} shorthand. CLI.Loader supports both asynchronous and synchronous loading
 * approaches, and leverage their advantages for the best development flow. We&#39;ll discuss about the pros and cons of each approach:
 *
 * # Asynchronous Loading #
 *
 * - Advantages:
 *     + Cross-domain
 *     + No web server needed: you can run the application via the file system protocol (i.e: `file://path/to/your/index
 *  .html`)
 *     + Best possible debugging experience: error messages come with the exact file name and line number
 *
 * - Disadvantages:
 *     + Dependencies need to be specified before-hand
 *
 * ### Method 1: Explicitly include what you need: ###
 *
 *     // Syntax
 *     CLI.require({String/Array} expressions);
 *
 *     // Example: Single alias
 *     CLI.require(&#39;widget.window&#39;);
 *
 *     // Example: Single class name
 *     CLI.require(&#39;CLI.window.Window&#39;);
 *
 *     // Example: Multiple aliases / class names mix
 *     CLI.require([&#39;widget.window&#39;, &#39;layout.border&#39;, &#39;CLI.data.Connection&#39;]);
 *
 *     // Wildcards
 *     CLI.require([&#39;widget.*&#39;, &#39;layout.*&#39;, &#39;CLI.data.*&#39;]);
 *
 * ### Method 2: Explicitly exclude what you don&#39;t need: ###
 *
 *     // Syntax: Note that it must be in this chaining format.
 *     CLI.exclude({String/Array} expressions)
 *        .require({String/Array} expressions);
 *
 *     // Include everything except CLI.data.*
 *     CLI.exclude(&#39;CLI.data.*&#39;).require(&#39;*&#39;);
 *
 *     // Include all widgets except widget.checkbox*,
 *     // which will match widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.
 *     CLI.exclude(&#39;widget.checkbox*&#39;).require(&#39;widget.*&#39;);
 *
 * # Synchronous Loading on Demand #
 *
 * - Advantages:
 *     + There&#39;s no need to specify dependencies before-hand, which is always the convenience of including ext-all.js
 *  before
 *
 * - Disadvantages:
 *     + Not as good debugging experience since file name won&#39;t be shown (except in Firebug at the moment)
 *     + Must be from the same domain due to XHR restriction
 *     + Need a web server, same reason as above
 *
 * There&#39;s one simple rule to follow: Instantiate everything with CLI.create instead of the `new` keyword
 *
 *     CLI.create(&#39;widget.window&#39;, { ... }); // Instead of new CLI.window.Window({...});
 *
 *     CLI.create(&#39;CLI.window.Window&#39;, {}); // Same as above, using full class name instead of alias
 *
 *     CLI.widget(&#39;window&#39;, {}); // Same as above, all you need is the traditional `xtype`
 *
 * Behind the scene, {@link CLI.ClassManager} will automatically check whether the given class name / alias has already
 *  existed on the page. If it&#39;s not, CLI.Loader will immediately switch itself to synchronous mode and automatic load the given
 *  class and all its dependencies.
 *
 * # Hybrid Loading - The Best of Both Worlds #
 *
 * It has all the advantages combined from asynchronous and synchronous loading. The development flow is simple:
 *
 * ### Step 1: Start writing your application using synchronous approach.
 *
 * CLI.Loader will automatically fetch all dependencies on demand as they&#39;re needed during run-time. For example:
 *
 *     CLI.onReady(function(){
 *         var window = CLI.widget(&#39;window&#39;, {
 *             width: 500,
 *             height: 300,
 *             layout: {
 *                 type: &#39;border&#39;,
 *                 padding: 5
 *             },
 *             title: &#39;Hello Dialog&#39;,
 *             items: [{
 *                 title: &#39;Navigation&#39;,
 *                 collapsible: true,
 *                 region: &#39;west&#39;,
 *                 width: 200,
 *                 html: &#39;Hello&#39;,
 *                 split: true
 *             }, {
 *                 title: &#39;TabPanel&#39;,
 *                 region: &#39;center&#39;
 *             }]
 *         });
 *
 *         window.show();
 *     })
 *
 * ### Step 2: Along the way, when you need better debugging ability, watch the console for warnings like these: ###
 *
 *     [CLI.Loader] Synchronously loading &#39;CLI.window.Window&#39;; consider adding CLI.require(&#39;CLI.window.Window&#39;) before your application&#39;s code
 *     ClassManager.js:432
 *     [CLI.Loader] Synchronously loading &#39;CLI.layout.container.Border&#39;; consider adding CLI.require(&#39;CLI.layout.container.Border&#39;) before your application&#39;s code
 *
 * Simply copy and paste the suggested code above `CLI.onReady`, i.e:
 *
 *     CLI.require(&#39;CLI.window.Window&#39;);
 *     CLI.require(&#39;CLI.layout.container.Border&#39;);
 *
 *     CLI.onReady(...);
 *
 * Everything should now load via asynchronous mode.
 *
 * # Deployment #
 *
 * It&#39;s important to note that dynamic loading should only be used during development on your local machines.
 * During production, all dependencies should be combined into one single JavaScript file. CLI.Loader makes
 * the whole process of transitioning from / to between development / maintenance and production as easy as
 * possible. Internally {@link CLI.Loader#history CLI.Loader.history} maintains the list of all dependencies your application
 * needs in the exact loading sequence. It&#39;s as simple as concatenating all files in this array into one,
 * then include it on top of your application.
 *
 * This process will be automated with Sencha Command, to be released and documented towards CLI Framework Final.
 *
 * @singleton
 */
(function() {

    // {{{ CLI.Loader

    CLI.Loader = new function() {

        var Loader = this,
            Manager = CLI.ClassManager, // this is an instance of CLI.Inventory
            Boot = CLI.Boot,
            Class = CLI.Class,
            alias = CLI.Function.alias,
            dependencyProperties = [&#39;extend&#39;, &#39;mixins&#39;, &#39;requires&#39;],
            isInHistory = {},
            history = [],
            usedClasses = [],
            _requiresMap = {},
            _missingQueue = {},
            _config = {

                // {{{ enabled

<span id='CLI-Loader-cfg-enabled'>                /**
</span>                 * @cfg {Boolean} [enabled=true]
                 * Whether or not to enable the dynamic dependency loading feature.
                 */
                enabled: true,

                // }}}
                // {{{ paths

<span id='CLI-Loader-cfg-paths'>                /**
</span>                 * @cfg {Object} paths
                 * The mapping from namespaces to file paths
                 *
                 *     {
                 *         &#39;CLI&#39;: &#39;.&#39;, // This is set by default, CLI.layout.container.Container will be
                 *                     // loaded from ./layout/Container.js
                 *
                 *         &#39;My&#39;: &#39;./src/my_own_folder&#39; // My.layout.Container will be loaded from
                 *                                     // ./src/my_own_folder/layout/Container.js
                 *     }
                 *
                 * Note that all relative paths are relative to the current HTML document.
                 * If not being specified, for example, `Other.awesome.Class` will simply be
                 * loaded from `&quot;./Other/awesome/Class.js&quot;`.
                 */
                paths: Manager.paths,

                // }}}

            };

        CLI.apply(Loader, {

            // {{{ isInHistory

<span id='CLI-Loader-property-isInHistory'>            /**
</span>             * @private
             */
            isInHistory: isInHistory,

            // }}}
            // {{{ history

<span id='CLI-Loader-property-history'>            /**
</span>             * An array of class names to keep track of the dependency loading order.
             * This is not guaranteed to be the same everytime due to the asynchronous
             * nature of the Loader.
             *
             * @property {Array} history
             */
            history: history,

            // }}}
            // {{{ config

<span id='CLI-Loader-property-config'>            /**
</span>             * Configuration
             * @private
             */
            config: _config,

            // }}}
            // {{{ requiresMap

<span id='CLI-Loader-property-requiresMap'>            /**
</span>             * Map of fully qualified class names to an array of dependent classes.
             * @private
             */
            requiresMap: _requiresMap,

            // }}}
            // {{{ hasFileLoadError

<span id='CLI-Loader-property-hasFileLoadError'>            /** @private */
</span>            hasFileLoadError: false,

            // }}}
            // {{{ missingQueue

<span id='CLI-Loader-property-missingQueue'>            /**
</span>             * @private
             */
            missingQueue: _missingQueue,

            // }}}
            // {{{ setConfig

<span id='CLI-Loader-method-setConfig'>            /**
</span>             * Set the configuration for the loader. This should be called right after ext-(debug).js
             *
             *     &lt;script type=&quot;text/javascript&quot; src=&quot;ext-core-debug.js&quot;&gt;&lt;/script&gt;
             *     &lt;script type=&quot;text/javascript&quot;&gt;
             *         CLI.Loader.setConfig({
             *           enabled: true,
             *           paths: {
             *               &#39;My&#39;: &#39;my_own_path&#39;
             *           }
             *         });
             *     &lt;/script&gt;
             *     &lt;script type=&quot;text/javascript&quot;&gt;
             *         CLI.require(...);
             *
             *         CLI.onReady(function() {
             *           // application code here
             *         });
             *     &lt;/script&gt;
             *
             * Refer to config options of {@link CLI.Loader} for the list of possible properties
             *
             * @param {Object} config The config object to override the default values
             * @return {CLI.Loader} this
             */
            setConfig: CLI.Function.flexSetter(function (name, value) {

                if (name === &#39;paths&#39;) {
                    Loader.setPath(value);
                } else {
                    _config[name] = value;
                }

                return Loader;
            }),

            // }}}
            // {{{ getConfig

<span id='CLI-Loader-method-getConfig'>            /**
</span>             * Get the config value corresponding to the specified name. If no name is given, will return the config object
             * @param {String} name The config property name
             * @return {Object}
             */
            getConfig: function(name) {

                return name ? _config[name] : _config;

            },

            // }}}
            // {{{ setPath

<span id='CLI-Loader-method-setPath'>            /**
</span>             * Sets the path of a namespace.
             * For Example:
             *
             *     CLI.Loader.setPath(&#39;CLI&#39;, &#39;.&#39;);
             *
             * @param {String/Object} name See {@link CLI.Function#flexSetter flexSetter}
             * @param {String} [path] See {@link CLI.Function#flexSetter flexSetter}
             * @return {CLI.Loader} this
             * @method
             */
            setPath: function () {

                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                Manager.setPath.apply(Manager, arguments);
                return Loader;
            },

            // }}}
            // {{{ addClassPathMappings

<span id='CLI-Loader-method-addClassPathMappings'>            /**
</span>             * Sets a batch of path entries
             *
             * @param {Object } paths a set of className: path mappings
             * @return {CLI.Loader} this
             */
            addClassPathMappings: function(paths) {

                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                Manager.setPath(paths);

                return Loader;

            },

            // }}}
            // {{{ getPath

<span id='CLI-Loader-method-getPath'>            /**
</span>             * Translates a className to a file path by adding the
             * the proper prefix and converting the .&#39;s to /&#39;s. For example:
             *
             *     CLI.Loader.setPath(&#39;My&#39;, &#39;/path/to/My&#39;);
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/path/to/My/awesome/Class.js&#39;
             *
             * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
             *
             *     CLI.Loader.setPath({
             *         &#39;My&#39;: &#39;/path/to/lib&#39;,
             *         &#39;My.awesome&#39;: &#39;/other/path/for/awesome/stuff&#39;,
             *         &#39;My.awesome.more&#39;: &#39;/more/awesome/path&#39;
             *     });
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/other/path/for/awesome/stuff/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.more.Class&#39;)); // alerts &#39;/more/awesome/path/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;My.cool.Class&#39;)); // alerts &#39;/path/to/lib/cool/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;Unknown.strange.Stuff&#39;)); // alerts &#39;Unknown/strange/Stuff.js&#39;
             *
             * @param {String} className
             * @return {String} path
             */
            getPath: function(className) {

                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                return Manager.getPath(className);

            },

            // }}}
            // {{{ require

            require: function (expressions, fn, scope, excludes) {

                if (excludes) {
                    return Loader.exclude(excludes).require(expressions, fn, scope);
                }

                var classNames = Manager.getNamesByExpression(expressions);

                return Loader.load(classNames, fn, scope);

            },

            // }}}
            // {{{ syncRequire

            syncRequire: function () {

                return Loader.require.apply(Loader, arguments);

            },

            // }}}
            // {{{ exclude

            exclude: function (excludes) {

                var selector = Manager.select({

                    require: function (classNames, fn, scope) {
                        return Loader.load(classNames, fn, scope);
                    },

                    syncRequire: function (classNames, fn, scope) {

                        var ret = Loader.load(classNames, fn, scope);

                        return ret;
                    }

                });

                selector.exclude(excludes);

                return selector;

            },

            // }}}
            // {{{ load

            load: function (classNames, callback, scope) {

                if (callback) {

                    if (callback.length) {
                        // If callback expects arguments, shim it with a function that will map
                        // the requires class(es) from the names we are given.
                        callback = Loader.makeLoadCallback(classNames, callback);
                    }

                    callback = callback.bind(scope || CLI.global);

                }

                var missingClassNames = [],
                    numClasses = classNames.length,
                    className, i, numMissing, urls = [],
                    state = Manager.classState;

                for (i = 0; i &lt; numClasses; ++i) {

                    className = Manager.resolveName(classNames[i]);

                    if (!Manager.isCreated(className)) {

                        missingClassNames.push(className);
                        _missingQueue[className] = Loader.getPath(className);

                        if(!state[className]) {
                            urls.push(_missingQueue[className]);
                        }

                    }

                }

                // If the dynamic dependency feature is not being used, throw an error
                // if the dependencies are not defined
                numMissing = missingClassNames.length;

                if (numMissing) {

                    Loader.missingCount += numMissing;

                    // We check for existence here (onExists vs onCreated) because overrides
                    // can come into existence but pause before being created until the target
                    // of the override has been created, which may not happen. For normal
                    // classes, this timing of this will be equivalent to onCreated.
                    Manager.onExists(function () {

                        if (callback) {
                            CLI.callback(callback, scope, arguments);
                        }

                    }, Loader, missingClassNames);

                    if (!_config.enabled) {

                        CLI.Error.raise(&quot;CLI.Loader is not enabled, so dependencies cannot be resolved dynamically. &quot; +
                                        &quot;Missing required class&quot; + ((missingClassNames.length &gt; 1) ? &quot;es&quot; : &quot;&quot;) +
                                        &quot;: &quot; + missingClassNames.join(&#39;, &#39;));
                    }

                    Loader.loadScripts({
                        url: urls,
                        // scope: this options object so we can pass these along:
                        _classNames: missingClassNames
                    });

                } else {

                    if (callback) {
                        callback.call(scope);
                    }

                }

                // Class may have been just loaded or was already loaded
                if (numClasses === 1) {

                    return Manager.get(classNames[0]);

                }

                return Loader;

            },

            // }}}
            // {{{ makeLoadCallback

            makeLoadCallback: function (classNames, callback) {

                return function () {

                    var classes = [],
                        i = classNames.length;

                    while (i-- &gt; 0) {
                        classes[i] = Manager.get(classNames[i]);
                    }

                    return callback.apply(this, classes);
                };

            },

            // }}}
            // {{{ addUsedClasses

<span id='CLI-Loader-method-addUsedClasses'>            /**
</span>             * @private
             * Ensure that any classes referenced in the `uses` property are loaded.
             */
            addUsedClasses: function (classes) {

                var cls, i, ln;

                if (classes) {

                    classes = (typeof classes === &#39;string&#39;) ? [classes] : classes;

                    for (i = 0, ln = classes.length; i &lt; ln; i++) {

                        cls = classes[i];

                        if (typeof cls === &#39;string&#39; &amp;&amp; !CLI.Array.contains(usedClasses, cls)) {

                            usedClasses.push(cls);

                        }

                    }

                }

                return Loader;

            },

            // }}}
            // {{{ historyPush

<span id='CLI-Loader-method-historyPush'>            /**
</span>             * @private
             * @param {String} className
             */
            historyPush: function(className) {
                if (className &amp;&amp; !isInHistory[className]) {
                    isInHistory[className] = true;
                    history.push(className);
                }
                return Loader;
            },

            // }}}
            // {{{ loadScripts

<span id='CLI-Loader-method-loadScripts'>            /**
</span>             * This is an internal method that delegate content loading to the
             * bootstrap layer.
             * @private
             * @param params
             */
            loadScripts: function(params) {

                var manifest = CLI.manifest,
                    options = params;

                ++Loader.scriptsLoading;

                CLI.iterate(options.url, function(t) {

                    t = require(&#39;path&#39;).normalize(t);

                    try {
                        require(t);
                    } catch(e) {
                        console.log(e);
                        process.exit();
                    }

                });

            }

            // }}}

        });

        // {{{ CLI.require

<span id='CLI-method-require'>        /**
</span>         * Loads all classes by the given names and all their direct dependencies; optionally
         * executes the given callback function when finishes, within the optional scope.
         *
         * @param {String/String[]} expressions The class, classes or wildcards to load.
         * @param {Function} [fn] The callback function.
         * @param {Object} [scope] The execution scope (`this`) of the callback function.
         * @member CLI
         * @method require
         */
        CLI.require = alias(Loader, &#39;require&#39;);

        // }}}
        // {{{ CLI.syncRequire

<span id='CLI-method-syncRequire'>        /**
</span>         * Synchronously loads all classes by the given names and all their direct dependencies; optionally
         * executes the given callback function when finishes, within the optional scope.
         *
         * @param {String/String[]} expressions The class, classes or wildcards to load.
         * @param {Function} [fn] The callback function.
         * @param {Object} [scope] The execution scope (`this`) of the callback function.
         * @member CLI
         * @method syncRequire
         */
        CLI.syncRequire = alias(Loader, &#39;syncRequire&#39;);

        // }}}
        // {{{ CLI.exclude

<span id='CLI-method-exclude'>        /**
</span>         * Explicitly exclude files from being loaded. Useful when used in conjunction with a
         * broad include expression. Can be chained with more `require` and `exclude` methods,
         * for example:
         *
         *     CLI.exclude(&#39;CLI.data.*&#39;).require(&#39;*&#39;);
         *
         *     CLI.exclude(&#39;widget.button*&#39;).require(&#39;widget.*&#39;);
         *
         * @param {String/String[]} excludes
         * @return {Object} Contains `exclude`, `require` and `syncRequire` methods for chaining.
         * @member CLI
         * @method exclude
         */
        CLI.exclude = alias(Loader, &#39;exclude&#39;);

        // }}}
        // {{{ loader

<span id='CLI-Class-cfg-requires'>        /**
</span>         * @cfg {String[]} requires
         * @member CLI.Class
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     CLI.define(&#39;Mother&#39;, {
         *         requires: [&#39;Child&#39;],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        Class.registerPreprocessor(&#39;loader&#39;, function(cls, data, hooks, continueFn) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(cls, &#39;CLI.Loader#loaderPreprocessor&#39;, arguments);

            var me = this,
                dependencies = [],
                dependency,
                className = Manager.getName(cls),
                i, j, ln, subLn, value, propertyName, propertyValue,
                requiredMap;

            for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {

                propertyName = dependencyProperties[i];

                if (data.hasOwnProperty(propertyName)) {

                    propertyValue = data[propertyName];

                    if (typeof propertyValue == &#39;string&#39;) {

                        dependencies.push(propertyValue);

                    } else if (propertyValue instanceof Array) {

                        for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {

                            value = propertyValue[j];

                            if (typeof value == &#39;string&#39;) {

                                dependencies.push(value);

                            }

                        }

                    } else if (typeof propertyValue != &#39;function&#39;) {

                        for (j in propertyValue) {

                            if (propertyValue.hasOwnProperty(j)) {

                                value = propertyValue[j];

                                if (typeof value == &#39;string&#39;) {

                                    dependencies.push(value);

                                }

                            }

                        }

                    }

                }

            }

            if (dependencies.length === 0) {

                return;

            }

            if (className) {

                _requiresMap[className] = dependencies;

            }

            var deadlockPath = [],
                detectDeadlock;

            if (className) {

                requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});

                for (i = 0,ln = dependencies.length; i &lt; ln; i++) {

                    dependency = dependencies[i];
                    (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);

                }

                detectDeadlock = function(cls) {

                    deadlockPath.push(cls);

                    if (_requiresMap[cls]) {

                        if (CLI.Array.contains(_requiresMap[cls], className)) {
                            CLI.Error.raise(&quot;Circular requirement detected! &#39;&quot; + className +
                                            &quot;&#39; and &#39;&quot; + deadlockPath[1] + &quot;&#39; mutually require each other. Path: &quot; +
                                            deadlockPath.join(&#39; -&gt; &#39;) + &quot; -&gt; &quot; + deadlockPath[0]);
                        }

                        for (i = 0,ln = _requiresMap[cls].length; i &lt; ln; i++) {
                            detectDeadlock(_requiresMap[cls][i]);
                        }
                    }
                };

                detectDeadlock(className);
            }

            (className ? Loader.exclude(className) : Loader).require(dependencies, function() {

                for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {

                    propertyName = dependencyProperties[i];

                    if (data.hasOwnProperty(propertyName)) {

                        propertyValue = data[propertyName];

                        if (typeof propertyValue == &#39;string&#39;) {

                            data[propertyName] = Manager.get(propertyValue);

                        } else if (propertyValue instanceof Array) {

                            for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {

                                value = propertyValue[j];

                                if (typeof value == &#39;string&#39;) {

                                    data[propertyName][j] = Manager.get(value);

                                }

                            }

                        } else if (typeof propertyValue != &#39;function&#39;) {

                            for (var k in propertyValue) {

                                if (propertyValue.hasOwnProperty(k)) {

                                    value = propertyValue[k];

                                    if (typeof value == &#39;string&#39;) {

                                        data[propertyName][k] = Manager.get(value);

                                    }
                                }

                            }

                        }

                    }

                }

                continueFn.call(me, cls, data, hooks);

            });

            return false;

        }, true, &#39;after&#39;, &#39;className&#39;);

        // }}}
        // {{{ uses

<span id='CLI-Class-cfg-uses'>        /**
</span>         * @cfg {String[]} uses
         * @member CLI.Class
         * List of optional classes to load together with this class. These aren&#39;t neccessarily loaded before
         * this class is created, but are guaranteed to be available before CLI.onReady listeners are
         * invoked. For example:
         *
         *     CLI.define(&#39;Mother&#39;, {
         *         uses: [&#39;Child&#39;],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use CLI.create() to load the class at the spot if not loaded already:
         *             return CLI.create(&#39;Child&#39;);
         *         }
         *     });
         */
        Manager.registerPostprocessor(&#39;uses&#39;, function(name, cls, data) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(cls, &#39;CLI.Loader#usesPostprocessor&#39;, arguments);

            var manifest = CLI.manifest,
                loadOrder = manifest &amp;&amp; manifest.loadOrder,
                classes = manifest &amp;&amp; manifest.classes,
                uses, clazz, item, len, i, indexMap;

            if (loadOrder) {

                clazz = classes[name];

                if (clazz &amp;&amp; !isNaN(i = clazz.idx)) {

                    item = loadOrder[i];
                    uses = item.uses;
                    indexMap = {};

                    for (len = uses.length, i = 0; i &lt; len; i++) {

                        indexMap[uses[i]] = true;

                    }

                    if (uses.length &gt; 0) {

                        Loader.loadScripts({
                            url: uses,
                            sequential: true
                        });

                    }

                }

            }

            if (data.uses) {

                uses = data.uses;
                Loader.addUsedClasses(uses);

            }

        });

        // }}}

        Manager.onCreated(Loader.historyPush);

    };

    // }}}

    CLI._endTime = new Date().getTime();

})();

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
