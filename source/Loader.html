<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * This file is part of CLI Framework
 */

<span id='CLI-Loader'>/**
</span> * @class CLI.Loader
 */

(function() {

    &quot;use strict&quot;;

<span id='CLI-Loader'>    /**
</span>     * @class CLI.Loader
     *
     * CLI.Loader is the heart of the new dynamic dependency loading capability in Ext JS 4+. It is most commonly used
     * via the {@link CLI#require} shorthand. CLI.Loader supports both asynchronous and synchronous loading
     * approaches, and leverage their advantages for the best development flow. We&#39;ll discuss about the pros and cons of each approach:
     *
     * # Asynchronous Loading #
     *
     * - Advantages:
     *     + Cross-domain
     *     + No web server needed: you can run the application via the file system protocol (i.e: `file://path/to/your/index
     *  .html`)
     *     + Best possible debugging experience: error messages come with the exact file name and line number
     *
     * - Disadvantages:
     *     + Dependencies need to be specified before-hand
     *
     * ### Method 1: Explicitly include what you need: ###
     *
     *     // Syntax
     *     CLI.require({String/Array} expressions);
     *
     *     // Example: Single alias
     *     CLI.require(&#39;widget.window&#39;);
     *
     *     // Example: Single class name
     *     CLI.require(&#39;CLI.window.Window&#39;);
     *
     *     // Example: Multiple aliases / class names mix
     *     CLI.require([&#39;widget.window&#39;, &#39;layout.border&#39;, &#39;CLI.data.Connection&#39;]);
     *
     *     // Wildcards
     *     CLI.require([&#39;widget.*&#39;, &#39;layout.*&#39;, &#39;CLI.data.*&#39;]);
     *
     * ### Method 2: Explicitly exclude what you don&#39;t need: ###
     *
     *     // Syntax: Note that it must be in this chaining format.
     *     CLI.exclude({String/Array} expressions)
     *        .require({String/Array} expressions);
     *
     *     // Include everything except CLI.data.*
     *     CLI.exclude(&#39;CLI.data.*&#39;).require(&#39;*&#39;);
     *
     *     // Include all widgets except widget.checkbox*,
     *     // which will match widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.
     *     CLI.exclude(&#39;widget.checkbox*&#39;).require(&#39;widget.*&#39;);
     *
     * # Synchronous Loading on Demand #
     *
     * - Advantages:
     *     + There&#39;s no need to specify dependencies before-hand, which is always the convenience of including ext-all.js
     *  before
     *
     * - Disadvantages:
     *     + Not as good debugging experience since file name won&#39;t be shown (except in Firebug at the moment)
     *     + Must be from the same domain due to XHR restriction
     *     + Need a web server, same reason as above
     *
     * There&#39;s one simple rule to follow: Instantiate everything with CLI.create instead of the `new` keyword
     *
     *     CLI.create(&#39;widget.window&#39;, { ... }); // Instead of new CLI.window.Window({...});
     *
     *     CLI.create(&#39;CLI.window.Window&#39;, {}); // Same as above, using full class name instead of alias
     *
     *     CLI.widget(&#39;window&#39;, {}); // Same as above, all you need is the traditional `xtype`
     *
     * Behind the scene, {@link CLI.ClassManager} will automatically check whether the given class name / alias has already
     *  existed on the page. If it&#39;s not, CLI.Loader will immediately switch itself to synchronous mode and automatic load the given
     *  class and all its dependencies.
     *
    * # Hybrid Loading - The Best of Both Worlds #
        *
        * It has all the advantages combined from asynchronous and synchronous loading. The development flow is simple:
        *
        * ### Step 1: Start writing your application using synchronous approach.
        *
        * CLI.Loader will automatically fetch all dependencies on demand as they&#39;re needed during run-time. For example:
        *
        *     CLI.onReady(function(){
                *         var window = CLI.widget(&#39;window&#39;, {
                        *             width: 500,
                        *             height: 300,
                        *             layout: {
                        *                 type: &#39;border&#39;,
                        *                 padding: 5
                        *             },
                        *             title: &#39;Hello Dialog&#39;,
                        *             items: [{
                        *                 title: &#39;Navigation&#39;,
                        *                 collapsible: true,
                        *                 region: &#39;west&#39;,
                        *                 width: 200,
                        *                 html: &#39;Hello&#39;,
                        *                 split: true
                        *             }, {
                        *                 title: &#39;TabPanel&#39;,
                        *                 region: &#39;center&#39;
                        *             }]
                        *         });
                *
                    *         window.show();
                *     })
                    *
                    * ### Step 2: Along the way, when you need better debugging ability, watch the console for warnings like these: ###
                    *
                    *     [CLI.Loader] Synchronously loading &#39;CLI.window.Window&#39;; consider adding CLI.require(&#39;CLI.window.Window&#39;) before your application&#39;s code
                    *     ClassManager.js:432
                    *     [CLI.Loader] Synchronously loading &#39;CLI.layout.container.Border&#39;; consider adding CLI.require(&#39;CLI.layout.container.Border&#39;) before your application&#39;s code
                    *
                    * Simply copy and paste the suggested code above `CLI.onReady`, i.e:
                    *
                    *     CLI.require(&#39;CLI.window.Window&#39;);
                *     CLI.require(&#39;CLI.layout.container.Border&#39;);
                *
                    *     CLI.onReady(...);
                *
                    * Everything should now load via asynchronous mode.
                    *
                    * # Deployment #
                    *
                    * It&#39;s important to note that dynamic loading should only be used during development on your local machines.
                    * During production, all dependencies should be combined into one single JavaScript file. CLI.Loader makes
                    * the whole process of transitioning from / to between development / maintenance and production as easy as
                    * possible. Internally {@link CLI.Loader#history CLI.Loader.history} maintains the list of all dependencies your application
                    * needs in the exact loading sequence. It&#39;s as simple as concatenating all files in this array into one,
                    * then include it on top of your application.
                        *
                        * This process will be automated with Sencha Command, to be released and documented towards Ext JS 4 Final.
                        *
                        * @singleton
                        */
    CLI.Loader = new function() {

        var Loader = this,
        Manager = CLI.ClassManager, // this is an instance of CLI.Inventory
        Boot = CLI.Boot,
        Class = CLI.Class,
        //        Ready = CLI.env.Ready,
        alias = CLI.Function.alias,
        dependencyProperties = [&#39;extend&#39;, &#39;mixins&#39;, &#39;requires&#39;],
        isInHistory = {},
        history = [],
        readyListeners = [],
        usedClasses = [],
        _requiresMap = {},
        _missingQueue = {},
        _config = {
<span id='CLI-Loader-cfg-enabled'>            /**
</span>             * @cfg {Boolean} [enabled=true]
             * Whether or not to enable the dynamic dependency loading feature.
             */
            enabled: true,

<span id='CLI-Loader-cfg-scriptChainDelay'>            /**
</span>             * @cfg {Boolean} [scriptChainDelay=false]
             * millisecond delay between asynchronous script injection (prevents stack
             * overflow on some user agents) &#39;false&#39; disables delay but potentially
             * increases stack load.
             */
            scriptChainDelay: false,

<span id='CLI-Loader-cfg-disableCaching'>            /**
</span>             * @cfg {Boolean} [disableCaching=true]
             * Appends current timestamp to script files to prevent caching.
             */
            disableCaching: true,

<span id='CLI-Loader-cfg-disableCachingParam'>            /**
</span>             * @cfg {String} [disableCachingParam=&quot;_dc&quot;]
             * The get parameter name for the cache buster&#39;s timestamp.
             */
            disableCachingParam: &#39;_dc&#39;,

<span id='CLI-Loader-cfg-paths'>            /**
</span>             * @cfg {Object} paths
             * The mapping from namespaces to file paths
             *
             *     {
             *         &#39;Ext&#39;: &#39;.&#39;, // This is set by default, CLI.layout.container.Container will be
             *                     // loaded from ./layout/Container.js
             *
             *         &#39;My&#39;: &#39;./src/my_own_folder&#39; // My.layout.Container will be loaded from
             *                                     // ./src/my_own_folder/layout/Container.js
             *     }
             *
             * Note that all relative paths are relative to the current HTML document.
             * If not being specified, for example, `Other.awesome.Class` will simply be
             * loaded from `&quot;./Other/awesome/Class.js&quot;`.
             */
            paths: Manager.paths,

<span id='CLI-Loader-cfg-preserveScripts'>            /**
</span>             * @cfg {Boolean} preserveScripts
             * `false` to remove asynchronously loaded scripts, `true` to retain script
             * element for browser debugger compatibility and improved load performance.
             */
            preserveScripts: true,

<span id='CLI-Loader-cfg-scriptCharset'>            /**
</span>             * @cfg {String} scriptCharset
             * Optional charset to specify encoding of dynamic script content.
             */
            scriptCharset: undefined
        },
        // These configs are delegated to CLI.Script and may need different names:
        delegatedConfigs = {
            disableCaching: true,
            disableCachingParam: true,
            preserveScripts: true,
            scriptChainDelay: &#39;loadDelay&#39;
        };

        CLI.apply(Loader, {
<span id='CLI-Loader-property-isInHistory'>            /**
</span>             * @private
             */
            isInHistory: isInHistory,

<span id='CLI-Loader-property-isLoading'>            /**
</span>             * Flag indicating whether there are still files being loaded
             * @private
             */
            isLoading: false,

<span id='CLI-Loader-property-history'>            /**
</span>             * An array of class names to keep track of the dependency loading order.
             * This is not guaranteed to be the same everytime due to the asynchronous
             * nature of the Loader.
             *
             * @property {Array} history
             */
            history: history,

<span id='CLI-Loader-property-config'>            /**
</span>             * Configuration
             * @private
             */
            config: _config,

<span id='CLI-Loader-property-readyListeners'>            /**
</span>             * Maintain the list of listeners to execute when all required scripts are fully loaded
             * @private
             */
            readyListeners: readyListeners,

<span id='CLI-Loader-property-optionalRequires'>            /**
</span>             * Contains classes referenced in `uses` properties.
             * @private
             */
            optionalRequires: usedClasses,

<span id='CLI-Loader-property-requiresMap'>            /**
</span>             * Map of fully qualified class names to an array of dependent classes.
             * @private
             */
            requiresMap: _requiresMap,

<span id='CLI-Loader-property-hasFileLoadError'>            /** @private */
</span>            hasFileLoadError: false,

<span id='CLI-Loader-property-scriptsLoading'>            /**
</span>             * The number of scripts loading via loadScript.
             * @private
             */
            scriptsLoading: 0,

            //&lt;debug&gt;
<span id='CLI-Loader-property-classesLoading'>            /**
</span>             * @private
             */
            classesLoading: [],
            //&lt;/debug&gt;

<span id='CLI-Loader-property-syncModeEnabled'>            /**
</span>             * @private
             */
            syncModeEnabled: false,


<span id='CLI-Loader-property-missingQueue'>            /**
</span>             * @private
             */
            missingQueue: _missingQueue,

            init: function () {

                /*
                // initalize the default path of the framework
                var //scripts = document.getElementsByTagName(&#39;script&#39;),
                //src = scripts[scripts.length - 1].src,
                path = src.substring(0, src.lastIndexOf(&#39;/&#39;) + 1),
                meta = CLI._classPathMetadata,
                microloader = CLI.Microloader,
                manifest = CLI.manifest,
                loadOrder, baseUrl, loadlen, l, loadItem;

                //&lt;debug&gt;
                if (src.indexOf(&quot;packages/sencha-core/src/&quot;) !== -1) {
                path = path + &quot;../../&quot;;
                } else if (src.indexOf(&quot;/core/src/class/&quot;) !== -1) {
                path = path + &quot;../../../&quot;;
                }
                //&lt;/debug&gt;


                if(!Manager.getPath(&quot;Ext&quot;)) {
                Manager.setPath(&#39;Ext&#39;, path + &#39;src&#39;);
                }

                // Pull in Cmd generated metadata if available.
                if (meta) {
                CLI._classPathMetadata = null;
                Loader.addClassPathMappings(meta);
                }

                if(manifest) {
                loadOrder = manifest.loadOrder;
                // if the manifest paths were calculated as relative to the 
                // bootstrap file, then we need to prepend Boot.baseUrl to the
                // paths before processing
                baseUrl = CLI.Boot.baseUrl;
                if(loadOrder &amp;&amp; manifest.bootRelative) {
                for(loadlen = loadOrder.length, l = 0; l &lt; loadlen; l++) {
                loadItem = loadOrder[l];
                loadItem.path = baseUrl + loadItem.path;
                }                    
                }
                }

                if(microloader) {
                Ready.block();
                microloader.onMicroloaderReady(function(){
                Ready.unblock();
                });
                }
                */
            },

<span id='CLI-Loader-method-setConfig'>            /**
</span>             * Set the configuration for the loader. This should be called right after ext-(debug).js
             * is included in the page, and before CLI.onReady. i.e:
             *
             *     &lt;script type=&quot;text/javascript&quot; src=&quot;ext-core-debug.js&quot;&gt;&lt;/script&gt;
             *     &lt;script type=&quot;text/javascript&quot;&gt;
             *         CLI.Loader.setConfig({
             *           enabled: true,
             *           paths: {
             *               &#39;My&#39;: &#39;my_own_path&#39;
             *           }
             *         });
             *     &lt;/script&gt;
             *     &lt;script type=&quot;text/javascript&quot;&gt;
             *         CLI.require(...);
             *
             *         CLI.onReady(function() {
             *           // application code here
             *         });
             *     &lt;/script&gt;
             *
             * Refer to config options of {@link CLI.Loader} for the list of possible properties
             *
             * @param {Object} config The config object to override the default values
             * @return {CLI.Loader} this
             */
            setConfig: CLI.Function.flexSetter(function (name, value) {
                if (name === &#39;paths&#39;) {
                    Loader.setPath(value);
                } else {
                    _config[name] = value;

                    var delegated = delegatedConfigs[name];
                    if (delegated) {
                        Boot.setConfig((delegated === true) ? name : delegated, value);
                    }
                }

                return Loader;
            }),

<span id='CLI-Loader-method-getConfig'>            /**
</span>             * Get the config value corresponding to the specified name. If no name is given, will return the config object
             * @param {String} name The config property name
             * @return {Object}
             */
            getConfig: function(name) {
                return name ? _config[name] : _config;
            },

<span id='CLI-Loader-method-setPath'>            /**
</span>             * Sets the path of a namespace.
             * For Example:
             *
             *     CLI.Loader.setPath(&#39;Ext&#39;, &#39;.&#39;);
             *
             * @param {String/Object} name See {@link CLI.Function#flexSetter flexSetter}
             * @param {String} [path] See {@link CLI.Function#flexSetter flexSetter}
             * @return {CLI.Loader} this
             * @method
             */
            setPath: function () {
                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                Manager.setPath.apply(Manager, arguments);
                return Loader;
            },

<span id='CLI-Loader-method-addClassPathMappings'>            /**
</span>             * Sets a batch of path entries
             *
             * @param {Object } paths a set of className: path mappings
             * @return {CLI.Loader} this
             */
            addClassPathMappings: function(paths) {
                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                Manager.setPath(paths);
                return Loader;
            },

<span id='CLI-Loader-method-addBaseUrlClassPathMappings'>            /**
</span>             * fixes up loader path configs by prepending CLI.Boot#baseUrl to the beginning
             * of the path, then delegates to CLI.Loader#addClassPathMappings
             * @param pathConfig
             */

            addBaseUrlClassPathMappings: function(pathConfig) {
                for(var name in pathConfig) {
                    pathConfig[name] = Boot.baseUrl + pathConfig[name];
                }
                CLI.Loader.addClassPathMappings(pathConfig);
            },


<span id='CLI-Loader-method-getPath'>            /**
</span>             * Translates a className to a file path by adding the
             * the proper prefix and converting the .&#39;s to /&#39;s. For example:
             *
             *     CLI.Loader.setPath(&#39;My&#39;, &#39;/path/to/My&#39;);
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/path/to/My/awesome/Class.js&#39;
             *
             * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
             *
             *     CLI.Loader.setPath({
             *         &#39;My&#39;: &#39;/path/to/lib&#39;,
             *         &#39;My.awesome&#39;: &#39;/other/path/for/awesome/stuff&#39;,
             *         &#39;My.awesome.more&#39;: &#39;/more/awesome/path&#39;
             *     });
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.Class&#39;)); // alerts &#39;/other/path/for/awesome/stuff/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;My.awesome.more.Class&#39;)); // alerts &#39;/more/awesome/path/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;My.cool.Class&#39;)); // alerts &#39;/path/to/lib/cool/Class.js&#39;
             *
             *     alert(CLI.Loader.getPath(&#39;Unknown.strange.Stuff&#39;)); // alerts &#39;Unknown/strange/Stuff.js&#39;
             *
             * @param {String} className
             * @return {String} path
             */
            getPath: function(className) {
                // Paths are an CLI.Inventory thing and ClassManager is an instance of that:
                return Manager.getPath(className);
            },

            require: function (expressions, fn, scope, excludes) {
                if (excludes) {
                    return Loader.exclude(excludes).require(expressions, fn, scope);
                }

                var classNames = Manager.getNamesByExpression(expressions);

                return Loader.load(classNames, fn, scope);
            },

            syncRequire: function () {
                var wasEnabled = Loader.syncModeEnabled;

                Loader.syncModeEnabled = true;

                var ret = Loader.require.apply(Loader, arguments);

                Loader.syncModeEnabled = wasEnabled;

                return ret;
            },

            exclude: function (excludes) {
                var selector = Manager.select({
                    require: function (classNames, fn, scope) {
                        return Loader.load(classNames, fn, scope);
                    },

                    syncRequire: function (classNames, fn, scope) {
                        var wasEnabled = Loader.syncModeEnabled;

                        Loader.syncModeEnabled = true;

                        var ret = Loader.load(classNames, fn, scope);

                        Loader.syncModeEnabled = wasEnabled;

                        return ret;
                    }
                });

                selector.exclude(excludes);
                return selector;
            },

            load: function (classNames, callback, scope) {
                if (callback) {
                    if (callback.length) {
                        // If callback expects arguments, shim it with a function that will map
                        // the requires class(es) from the names we are given.
                        callback = Loader.makeLoadCallback(classNames, callback);
                    }
                    callback = callback.bind(scope || CLI.global);
                }

                var missingClassNames = [],
                numClasses = classNames.length,
                className, i, numMissing, urls = [],
                state = Manager.classState;

                for (i = 0; i &lt; numClasses; ++i) {
                    className = Manager.resolveName(classNames[i]);
                    if (!Manager.isCreated(className)) {
                        missingClassNames.push(className);
                        _missingQueue[className] = Loader.getPath(className);
                        if(!state[className]) {
                            urls.push(_missingQueue[className]);
                        }
                    }
                }

                // If the dynamic dependency feature is not being used, throw an error
                // if the dependencies are not defined
                numMissing = missingClassNames.length;
                if (numMissing) {
                    Loader.missingCount += numMissing;
                    //&lt;debug&gt;
                    CLI.Array.push(Loader.classesLoading, missingClassNames);
                    //&lt;/debug&gt;

                    // We check for existence here (onExists vs onCreated) because overrides
                    // can come into existence but pause before being created until the target
                    // of the override has been created, which may not happen. For normal
                    // classes, this timing of this will be equivalent to onCreated.
                    Manager.onExists(function () {
                        //&lt;debug&gt;
                        CLI.Array.remove(Loader.classesLoading, missingClassNames);
                        CLI.each(missingClassNames, function(name){
                            CLI.Array.remove(Loader.classesLoading, name);
                        });
                        //&lt;/debug&gt;
                        if (callback) {
                            CLI.callback(callback, scope, arguments);
                        }
                        Loader.checkReady();
                    }, Loader, missingClassNames);

                    if (!_config.enabled) {
                        CLI.Error.raise(&quot;CLI.Loader is not enabled, so dependencies cannot be resolved dynamically. &quot; +
                                        &quot;Missing required class&quot; + ((missingClassNames.length &gt; 1) ? &quot;es&quot; : &quot;&quot;) + 
                                        &quot;: &quot; + missingClassNames.join(&#39;, &#39;));
                    }

                    if(urls.length) {
                        Loader.loadScripts({
                            url: urls,
                            // scope: this options object so we can pass these along:
                            _classNames: missingClassNames
                        });
                    } else {
                        // need to call checkReady here, as the _missingCoun
                        // may have transitioned from 0 to &gt; 0, meaning we
                        // need to block ready
                        Loader.checkReady();
                    }
                } else {
                    if (callback) {
                        callback.call(scope);
                    }
                    // need to call checkReady here, as the _missingCoun
                    // may have transitioned from 0 to &gt; 0, meaning we
                    // need to block ready
                    Loader.checkReady();
                }

                if (Loader.syncModeEnabled) {
                    // Class may have been just loaded or was already loaded
                    if (numClasses === 1) {
                        return Manager.get(classNames[0]);
                    }
                }

                return Loader;
            },

            makeLoadCallback: function (classNames, callback) {
                return function () {
                    var classes = [],
                    i = classNames.length;

                    while (i-- &gt; 0) {
                        classes[i] = Manager.get(classNames[i]);
                    }

                    return callback.apply(this, classes);
                }
            },

            onLoadFailure: function () {
                var options = this,
                onError = options.onError;

                Loader.hasFileLoadError = true;
                --Loader.scriptsLoading;

                if (onError) {
                    //TODO: need an adapter to convert to v4 onError signatures
                    onError.call(options.userScope, options);
                }
                //&lt;debug&gt;
                else {
                    CLI.log.error(&quot;[CLI.Loader] Some requested files failed to load.&quot;);
                }
                //&lt;/debug&gt;

                Loader.checkReady();
            },

            onLoadSuccess: function () {
                var options = this,
                onLoad = options.onLoad;

                --Loader.scriptsLoading;
                if (onLoad) {
                    //TODO: need an adapter to convert to v4 onLoad signatures
                    onLoad.call(options.userScope, options);
                    // onLoad can cause more loads to start, so it must run first
                }

                Loader.checkReady();
            },

            // TODO: this timing of this needs to be deferred until all classes have had a chance to be created
            //&lt;debug&gt;
            reportMissingClasses: function () {
                if (!Loader.syncModeEnabled &amp;&amp; !Loader.scriptsLoading &amp;&amp; Loader.isLoading &amp;&amp;
                    !Loader.hasFileLoadError) {
                    var missingClasses = [],
                missingPaths = [];

                for (var missingClassName in _missingQueue) {
                    missingClasses.push(missingClassName);
                    missingPaths.push(_missingQueue[missingClassName]);
                }

                if (missingClasses.length) {
                    throw new Error(&quot;The following classes are not declared even if their files have been &quot; +
                                    &quot;loaded: &#39;&quot; + missingClasses.join(&quot;&#39;, &#39;&quot;) + &quot;&#39;. Please check the source code of their &quot; +
                                    &quot;corresponding files for possible typos: &#39;&quot; + missingPaths.join(&quot;&#39;, &#39;&quot;));
                }
                }
            },
            //&lt;/debug&gt;

<span id='CLI-Loader-method-onReady'>            /**
</span>             * Add a new listener to be executed when all required scripts are fully loaded
             *
             * @param {Function} fn The function callback to be executed
             * @param {Object} scope The execution scope (`this`) of the callback function.
             * @param {Boolean} [withDomReady=true] Pass `false` to not also wait for document
             * dom ready.
             * @param {Object} [options] Additional callback options.
             * @param {Number} [options.delay=0] A number of milliseconds to delay.
             * @param {Number} [options.priority=0] Relative priority of this callback. Negative
             * numbers are reserved.
             */
            onReady: function(fn, scope, withDomReady, options) {
                if (withDomReady) {
                    Ready.on(fn, scope, options);
                } else {
                    var listener = Ready.makeListener(fn, scope, options);

                    if (Loader.isLoading) {
                        readyListeners.push(listener);
                    } else {
                        Ready.invoke(listener);
                    }
                }
            },

<span id='CLI-Loader-method-addUsedClasses'>            /**
</span>             * @private
             * Ensure that any classes referenced in the `uses` property are loaded.
             */
            addUsedClasses: function (classes) {
                var cls, i, ln;

                if (classes) {
                    classes = (typeof classes === &#39;string&#39;) ? [classes] : classes;
                    for (i = 0, ln = classes.length; i &lt; ln; i++) {
                        cls = classes[i];
                        if (typeof cls === &#39;string&#39; &amp;&amp; !CLI.Array.contains(usedClasses, cls)) {
                            usedClasses.push(cls);
                        }
                    }
                }

                return Loader;
            },

<span id='CLI-Loader-method-triggerReady'>            /**
</span>             * @private
             */
            triggerReady: function() {
                var listener,
                refClasses = usedClasses;

                if (Loader.isLoading &amp;&amp; refClasses.length) {
                    // Empty the array to eliminate potential recursive loop issue
                    usedClasses = [];

                    // this may immediately call us back if all &#39;uses&#39; classes
                    // have been loaded
                    Loader.require(refClasses);
                } else {
                    // Must clear this before calling callbacks. This will cause any new loads
                    // to call Ready.block() again. See below for more on this.
                    Loader.isLoading = false;

                    // These listeners are just those attached directly to Loader to wait for
                    // class loading only.
                    readyListeners.sort(Ready.sortFn);

                    // this method can be called with Loader.isLoading either true or false
                    // (can be called with false when all &#39;uses&#39; classes are already loaded)
                    // this may bypass the above if condition
                    while (readyListeners.length &amp;&amp; !Loader.isLoading) {
                        // we may re-enter triggerReady so we cannot necessarily iterate the
                        // readyListeners array
                        listener = readyListeners.pop();
                        Ready.invoke(listener);
                    }

                    // If the DOM is also ready, this will fire the normal onReady listeners.
                    // An astute observer would note that we may now be back to isLoading and
                    // so ask &quot;Why you call unblock?&quot;. The reason is that we must match the
                    // calls to block and since we transitioned from isLoading to !isLoading
                    // here we must call unblock. If we have transitioned back to isLoading in
                    // the above loop it will have called block again so the counter will be
                    // increased and this call will not reduce the block count to 0. This is
                    // done by loadScripts.
                    Ready.unblock();
                }
            },

<span id='CLI-Loader-method-historyPush'>            /**
</span>             * @private
             * @param {String} className
             */
            historyPush: function(className) {
                if (className &amp;&amp; !isInHistory[className]) {
                    isInHistory[className] = true;
                    history.push(className);
                }
                return Loader;
            },

<span id='CLI-Loader-method-loadScripts'>            /**
</span>             * This is an internal method that delegate content loading to the 
             * bootstrap layer.
             * @private
             * @param params
             */
            loadScripts: function(params) {
                var manifest = CLI.manifest,
                loadOrder = manifest &amp;&amp; manifest.loadOrder,
                loadOrderMap = manifest &amp;&amp; manifest.loadOrderMap,
                options;

                ++Loader.scriptsLoading;

                // if the load order map hasn&#39;t been created, create it now 
                // and cache on the manifest
                if (loadOrder &amp;&amp; !loadOrderMap) {
                    manifest.loadOrderMap = loadOrderMap = Boot.createLoadOrderMap(loadOrder);
                }

                // verify the loading state, as this may have transitioned us from
                // not loading to loading
                Loader.checkReady();

                options = CLI.apply({
                    loadOrder: loadOrder,
                    loadOrderMap: loadOrderMap,
                    charset: _config.scriptCharset,
                    success: Loader.onLoadSuccess,
                    failure: Loader.onLoadFailure,
                    sync: Loader.syncModeEnabled,
                    _classNames: []
                }, params);

                options.userScope = options.scope;
                options.scope = options;

                Boot.load(options);
            },

<span id='CLI-Loader-method-loadScriptsSync'>            /**
</span>             * This method is provide for use by the bootstrap layer.
             * @private
             * @param {String[]} urls
             */
            loadScriptsSync: function(urls) {
                var syncwas = Loader.syncModeEnabled;
                Loader.syncModeEnabled = true;
                Loader.loadScripts({url: urls});
                Loader.syncModeEnabled = syncwas;
            },

<span id='CLI-Loader-method-loadScriptsSyncBasePrefix'>            /**
</span>             * This method is provide for use by the bootstrap layer.
             * @private
             * @param {String[]} urls
             */
            loadScriptsSyncBasePrefix: function(urls) {
                var syncwas = Loader.syncModeEnabled;
                Loader.syncModeEnabled = true;
                Loader.loadScripts({url: urls, prependBaseUrl: true});
                Loader.syncModeEnabled = syncwas;
            },

<span id='CLI-Loader-method-loadScript'>            /**
</span>             * Loads the specified script URL and calls the supplied callbacks. If this method
             * is called before {@link CLI#isReady}, the script&#39;s load will delay the transition
             * to ready. This can be used to load arbitrary scripts that may contain further
             * {@link CLI#require CLI.require} calls.
             *
             * @param {Object/String/String[]} options The options object or simply the URL(s) to load.
             * @param {String} options.url The URL from which to load the script.
             * @param {Function} [options.onLoad] The callback to call on successful load.
             * @param {Function} [options.onError] The callback to call on failure to load.
             * @param {Object} [options.scope] The scope (`this`) for the supplied callbacks.
             */
            loadScript: function(options) {
                var isString = typeof options === &#39;string&#39;,
                isArray = options instanceof Array,
                isObject = !isArray &amp;&amp; !isString,
                url = isObject ? options.url : options,
                onError = isObject &amp;&amp; options.onError,
                onLoad = isObject &amp;&amp; options.onLoad,
                scope = isObject &amp;&amp; options.scope,
                request = {
                    url: url,
                    scope: scope,
                    onLoad: onLoad,
                    onError: onError,
                    _classNames: []
                };

                Loader.loadScripts(request);
            },

<span id='CLI-Loader-method-flushMissingQueue'>            /**
</span>             * @private
             */
            flushMissingQueue: function() {
                var name, val, missingwas = 0, missing = 0;

                for(name in _missingQueue) {
                    missingwas++;
                    val = _missingQueue[name];
                    if(Manager.isCreated(name)) {
                        delete _missingQueue[name];
                    } else if (Manager.existCache[name] === 2) {
                        delete _missingQueue[name];
                    } else {
                        ++missing;
                    }
                }
                this.missingCount = missing;
            },

<span id='CLI-Loader-method-checkReady'>            /**
</span>             * @private
             */
            checkReady: function() {
                var wasLoading = Loader.isLoading,
                isLoading;

                Loader.flushMissingQueue();
                isLoading = Loader.missingCount + Loader.scriptsLoading;

                if(isLoading &amp;&amp; !wasLoading) {
                    //Ready.block();
                    Loader.isLoading = !!isLoading;
                } else if (!isLoading &amp;&amp; wasLoading) {
                    Loader.triggerReady();
                }
            }
        });

<span id='Ext-method-require'>        /**
</span>         * Loads all classes by the given names and all their direct dependencies; optionally
         * executes the given callback function when finishes, within the optional scope.
         *
         * @param {String/String[]} expressions The class, classes or wildcards to load.
         * @param {Function} [fn] The callback function.
         * @param {Object} [scope] The execution scope (`this`) of the callback function.
         * @member Ext
         * @method require
         */
        CLI.require = alias(Loader, &#39;require&#39;);

<span id='Ext-method-syncRequire'>        /**
</span>         * Synchronously loads all classes by the given names and all their direct dependencies; optionally
         * executes the given callback function when finishes, within the optional scope.
         *
         * @param {String/String[]} expressions The class, classes or wildcards to load.
         * @param {Function} [fn] The callback function.
         * @param {Object} [scope] The execution scope (`this`) of the callback function.
         * @member Ext
         * @method syncRequire
         */
        CLI.syncRequire = alias(Loader, &#39;syncRequire&#39;);

<span id='Ext-method-exclude'>        /**
</span>         * Explicitly exclude files from being loaded. Useful when used in conjunction with a
         * broad include expression. Can be chained with more `require` and `exclude` methods,
         * for example:
         *
         *     CLI.exclude(&#39;CLI.data.*&#39;).require(&#39;*&#39;);
         *
         *     CLI.exclude(&#39;widget.button*&#39;).require(&#39;widget.*&#39;);
         *
         * @param {String/String[]} excludes
         * @return {Object} Contains `exclude`, `require` and `syncRequire` methods for chaining.
         * @member Ext
         * @method exclude
         */
        CLI.exclude = alias(Loader, &#39;exclude&#39;);

        //&lt;feature classSystem.loader&gt;
<span id='CLI-Class-cfg-requires'>        /**
</span>         * @cfg {String[]} requires
         * @member CLI.Class
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     CLI.define(&#39;Mother&#39;, {
         *         requires: [&#39;Child&#39;],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        Class.registerPreprocessor(&#39;loader&#39;, function(cls, data, hooks, continueFn) {
            //&lt;debug&gt;
            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(cls, &#39;CLI.Loader#loaderPreprocessor&#39;, arguments);
            //&lt;/debug&gt;

            var me = this,
            dependencies = [],
            dependency,
            className = Manager.getName(cls),
            i, j, ln, subLn, value, propertyName, propertyValue,
            requiredMap;

            /*
               Loop through the dependencyProperties, look for string class names and push
               them into a stack, regardless of whether the property&#39;s value is a string, array or object. For example:
               {
extend: &#39;CLI.MyClass&#39;,
requires: [&#39;CLI.some.OtherClass&#39;],
mixins: {
thing: &#39;Foo.bar.Thing&#39;;
}
}
which will later be transformed into:
{
extend: CLI.MyClass,
requires: [CLI.some.OtherClass],
mixins: {
thing: Foo.bar.Thing;
}
}
*/

for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
    propertyName = dependencyProperties[i];

    if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];

        if (typeof propertyValue == &#39;string&#39;) {
            dependencies.push(propertyValue);
        }
        else if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                value = propertyValue[j];

                if (typeof value == &#39;string&#39;) {
                    dependencies.push(value);
                }
            }
        }
        else if (typeof propertyValue != &#39;function&#39;) {
            for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                    value = propertyValue[j];

                    if (typeof value == &#39;string&#39;) {
                        dependencies.push(value);
                    }
                }
            }
        }
    }
}

if (dependencies.length === 0) {
    return;
}
if (className) {
    _requiresMap[className] = dependencies;
}

//&lt;debug&gt;
var deadlockPath = [],
    detectDeadlock;

/*
   Automatically detect deadlocks before-hand,
   will throw an error with detailed path for ease of debugging. Examples of deadlock cases:

   - A extends B, then B extends A
   - A requires B, B requires C, then C requires A

   The detectDeadlock function will recursively transverse till the leaf, hence it can detect deadlocks
   no matter how deep the path is.
   */

if (className) {
    requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});

        for (i = 0,ln = dependencies.length; i &lt; ln; i++) {
            dependency = dependencies[i];
            (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
        }

        detectDeadlock = function(cls) {
            deadlockPath.push(cls);

            if (_requiresMap[cls]) {
                if (CLI.Array.contains(_requiresMap[cls], className)) {
                    CLI.Error.raise(&quot;Circular requirement detected! &#39;&quot; + className +
                                    &quot;&#39; and &#39;&quot; + deadlockPath[1] + &quot;&#39; mutually require each other. Path: &quot; +
                                    deadlockPath.join(&#39; -&gt; &#39;) + &quot; -&gt; &quot; + deadlockPath[0]);
                }

                for (i = 0,ln = _requiresMap[cls].length; i &lt; ln; i++) {
                    detectDeadlock(_requiresMap[cls][i]);
                }
            }
        };

        detectDeadlock(className);
    }

    //&lt;/debug&gt;

    (className ? Loader.exclude(className) : Loader).require(dependencies, function() {
        for (i = 0,ln = dependencyProperties.length; i &lt; ln; i++) {
            propertyName = dependencyProperties[i];

            if (data.hasOwnProperty(propertyName)) {
                propertyValue = data[propertyName];

                if (typeof propertyValue == &#39;string&#39;) {
                    data[propertyName] = Manager.get(propertyValue);
                }
                else if (propertyValue instanceof Array) {
                    for (j = 0, subLn = propertyValue.length; j &lt; subLn; j++) {
                        value = propertyValue[j];

                        if (typeof value == &#39;string&#39;) {
                            data[propertyName][j] = Manager.get(value);
                        }
                    }
                }
                else if (typeof propertyValue != &#39;function&#39;) {
                    for (var k in propertyValue) {
                        if (propertyValue.hasOwnProperty(k)) {
                            value = propertyValue[k];

                            if (typeof value == &#39;string&#39;) {
                                data[propertyName][k] = Manager.get(value);
                            }
                        }
                    }
                }
            }
        }

        continueFn.call(me, cls, data, hooks);
    });

    return false;
        }, true, &#39;after&#39;, &#39;className&#39;);

<span id='CLI-Class-cfg-uses'>        /**
</span>         * @cfg {String[]} uses
         * @member CLI.Class
         * List of optional classes to load together with this class. These aren&#39;t neccessarily loaded before
         * this class is created, but are guaranteed to be available before CLI.onReady listeners are
         * invoked. For example:
         *
         *     CLI.define(&#39;Mother&#39;, {
         *         uses: [&#39;Child&#39;],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use CLI.create() to load the class at the spot if not loaded already:
         *             return CLI.create(&#39;Child&#39;);
         *         }
         *     });
         */
        Manager.registerPostprocessor(&#39;uses&#39;, function(name, cls, data) {
            //&lt;debug&gt;
            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(cls, &#39;CLI.Loader#usesPostprocessor&#39;, arguments);
            //&lt;/debug&gt;

            var manifest = CLI.manifest,
            loadOrder = manifest &amp;&amp; manifest.loadOrder,
            classes = manifest &amp;&amp; manifest.classes,
            uses, clazz, item, len, i, indexMap;

            if (loadOrder) {
                clazz = classes[name];
                if (clazz &amp;&amp; !isNaN(i = clazz.idx)) {
                    item = loadOrder[i];
                    uses = item.uses;
                    indexMap = {};
                    for (len = uses.length, i = 0; i &lt; len; i++) {
                        indexMap[uses[i]] = true;
                    }
                    uses = CLI.Boot.getPathsFromIndexes(indexMap, loadOrder, true);
                    if (uses.length &gt; 0) {
                        Loader.loadScripts({
                            url: uses,
                            sequential: true
                        });
                    }
                }
            }

            if (data.uses) {
                uses = data.uses;
                Loader.addUsedClasses(uses);
            }
        });

        Manager.onCreated(Loader.historyPush);
        //&lt;/feature&gt;

        Loader.init();

    };

    //-----------------------------------------------------------------------------

    CLI._endTime = new Date().getTime();

    // This hook is to allow tools like DynaTrace to deterministically detect the availability
    // of CLI.onReady. Since Loader takes over CLI.onReady this must be done here and not in
    // CLI.env.Ready.
    if (CLI._beforereadyhandler){
        CLI._beforereadyhandler();
    }

})();

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
