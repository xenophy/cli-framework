<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * This file is part of CLI Framework
 */

<span id='CLI-Base'>/**
</span> * @class CLI.Base
 *
 * The root of all classes created with {@link CLI#define}.
 *
 * CLI.Base is the building block of all CLI classes. All classes in CLI inherit from CLI.Base.
 * All prototype and static members of this class are inherited by all other classes.
 */
CLI.Base = (function(flexSetter) {

    var noArgs = [],
        baseStaticMember,
        baseStaticMembers = [],
        getConfig = function (name, peek) {

            var me = this,
                ret, cfg, getterName;

            if (name) {

                cfg = CLI.Config.map[name];

                if (!cfg) {
                    CLI.Logger.error(&quot;Invalid property name for getter: &#39;&quot; + name + &quot;&#39; for &#39;&quot; + me.$className + &quot;&#39;.&quot;);
                }

                getterName = cfg.names.get;

                if (peek &amp;&amp; me.hasOwnProperty(getterName)) {

                    ret = me.config[name];

                } else {

                    ret = me[getterName]();

                }

            } else {

                ret = me.getCurrentConfig();

            }

            return ret;
        },
        makeDeprecatedMethod = function (oldName, newName, msg) {

            var message = &#39;&quot;&#39;+ oldName +&#39;&quot; is deprecated.&#39;;

            if (msg) {

                message += &#39; &#39; + msg;

            } else if (newName) {

                message += &#39; Please use &quot;&#39;+ newName +&#39;&quot; instead.&#39;;

            }

            return function () {

                CLI.Error.raise(message);

            };

        },
        addDeprecatedProperty = function (object, oldName, newName, message) {

            if (!message) {
                message = &#39;&quot;&#39; + oldName + &#39;&quot; is deprecated.&#39;;
            }

            if (newName) {
                message += &#39; Please use &quot;&#39; + newName + &#39;&quot; instead.&#39;;
            }

            if (message) {

                CLI.Object.defineProperty(object, oldName, {

                    get: function() {

                        CLI.Error.raise(message);

                    },

                    set: function(value) {

                        CLI.Error.raise(message);

                    },

                    configurable: true

                });

            }

        },
        makeAliasFn = function (name) {

            return function () {

                return this[name].apply(this, arguments);

            };

        },
        Version = CLI.Version,
        leadingDigitRe = /^\d/,
        oneMember = {},
        aliasOneMember = {},
        Base = function(){},
        BasePrototype = Base.prototype;

    // These static properties will be copied to every newly created class with {@link CLI#define}
    CLI.apply(Base, {

        // {{{ $className

        $className: &#39;CLI.Base&#39;,

        // }}}
        // {{{ $isClass

        $isClass: true,

        // }}}
        // {{{ create

<span id='CLI-Base-static-method-create'>        /**
</span>         * Create a new instance of this Class.
         *
         *     CLI.define(&#39;My.cool.Class&#39;, {
         *         ...
         *     });
         *
         *     My.cool.Class.create({
         *         someConfig: true
         *     });
         *
         * All parameters are passed to the constructor of the class.
         *
         * @return {Object} the created instance.
         * @static
         * @inheritable
         */
        create: function() {
            return CLI.create.apply(CLI, [this].concat(Array.prototype.slice.call(arguments, 0)));
        },

        // }}}
        // {{{ addDeprecations

<span id='CLI-Base-method-addDeprecations'>        /**
</span>         * This method applies a versioned, deprecation declaration to this class. This
         * is typically called by the `deprecated` config.
         * @private
         */
        addDeprecations: function (deprecations) {

            var me = this,
                all = [],
                compatVersion = CLI.getCompatVersion(deprecations.name),
                displayName = (me.$className || &#39;&#39;) + &#39;#&#39;,
                deprecate, versionSpec, index, message, target,
                enabled, existing, fn, names, oldName, newName, member, statics, version;

            for (versionSpec in deprecations) {

                if (leadingDigitRe.test(versionSpec)) {

                    version = new CLI.Version(versionSpec);
                    version.deprecations = deprecations[versionSpec];
                    all.push(version);

                }

            }

            all.sort(Version.compare);

            for (index = all.length; index--; ) {

                deprecate = (version = all[index]).deprecations;
                target = me.prototype;
                statics = deprecate.statics;

                // If user specifies, say 4.2 compatibility and we have a 5.0 deprecation
                // then that block needs to be &quot;enabled&quot; to &quot;revert&quot; to behaviors prior
                // to 5.0. By default, compatVersion === currentVersion, so there are no
                // enabled blocks. In dev mode we still want to visit all the blocks and
                // possibly add shims to detect use of deprecated methods, but in a build
                // (if the deprecated block remains somehow) we just break the loop.
                enabled = compatVersion &amp;&amp; compatVersion.lt(version);

                if (!enabled) {
                } else if (!enabled) {
                    break;
                }

                while (deprecate) {

                    names = deprecate.methods;

                    if (names) {

                        for (oldName in names) {

                            member = names[oldName];
                            fn = null;

                            if (!member) {

                                /*
                                 * Something like:
                                 *
                                 *      &#39;5.1&#39;: {
                                 *          methods: {
                                 *              removedMethod: null
                                 *          }
                                 *      }
                                 *
                                 * Since there is no recovering the method, we always put
                                 * on a shim to catch abuse.
                                 */

                                // The class should not already have a method by the oldName
                                CLI.Assert.isNotDefinedProp(target, oldName);

                                fn = makeDeprecatedMethod(displayName + oldName);

                            } else if (CLI.isString(member)) {

                                /*
                                 * Something like:
                                 *
                                 *      &#39;5.1&#39;: {
                                 *          methods: {
                                 *              oldName: &#39;newName&#39;
                                 *          }
                                 *      }
                                 *
                                 * If this block is enabled, we just put an alias in place.
                                 * Otherwise we need to inject a
                                 */

                                // The class should not already have a method by the oldName
                                CLI.Assert.isNotDefinedProp(target, oldName);
                                CLI.Assert.isDefinedProp(target, member);

                                if (enabled) {

                                    // This call to the real method name must be late
                                    // bound if it is to pick up overrides and such.
                                    fn = makeAliasFn(member);

                                } else {

                                    fn = makeDeprecatedMethod(displayName + oldName, member);

                                }

                            } else {

                                /*
                                 * Something like:
                                 *
                                 *      &#39;5.1&#39;: {
                                 *          methods: {
                                 *              foo: function () { ... }
                                 *          }
                                 *      }
                                 *
                                 * Or this:
                                 *
                                 *      &#39;5.1&#39;: {
                                 *          methods: {
                                 *              foo: {
                                 *                  fn: function () { ... },
                                 *                  message: &#39;Please use &quot;bar&quot; instead.&#39;
                                 *              }
                                 *          }
                                 *      }
                                 *
                                 * Or just this:
                                 *
                                 *      &#39;5.1&#39;: {
                                 *          methods: {
                                 *              foo: {
                                 *                  message: &#39;Use something else instead.&#39;
                                 *              }
                                 *          }
                                 *      }
                                 *
                                 * If this block is enabled, and &quot;foo&quot; is an existing
                                 * method, than we apply the given method as an override.
                                 * If &quot;foo&quot; is not existing, we simply add the method.
                                 *
                                 * If the block is not enabled and there is no existing
                                 * method by that name, than we add a shim to prevent
                                 * abuse.
                                 */
                                message = &#39;&#39;;

                                if (member.message || member.fn) {
                                    message = member.message;
                                    member = member.fn;
                                }

                                existing = target.hasOwnProperty(oldName) &amp;&amp; target[oldName];

                                if (enabled &amp;&amp; member) {

                                    member.$owner = me;
                                    member.$name = oldName;
                                    member.displayName = displayName + oldName;

                                    if (existing) {
                                        member.$previous = existing;
                                    }

                                    fn = member;

                                } else if (!existing) {

                                    fn = makeDeprecatedMethod(displayName + oldName, null, message);

                                }

                            }

                            if (fn) {

                                target[oldName] = fn;

                            }

                        }

                    }

                    names = deprecate.properties;

                    if (names &amp;&amp; !enabled) {

                        // For properties about the only thing we can do is (on Good
                        // Browsers), add warning shims for accessing them. So if the
                        // block is enabled, we don&#39;t want those.

                        for (oldName in names) {

                            newName = names[oldName];

                            if (CLI.isString(newName)) {

                                addDeprecatedProperty(target, displayName + oldName, newName);

                            } else if (newName &amp;&amp; newName.message) {

                                addDeprecatedProperty(target, displayName + oldName, null, newName.message);

                            } else {

                                addDeprecatedProperty(target, displayName + oldName);

                            }

                        }

                    }

                    // reset to handle statics and apply them to the class
                    deprecate   = statics;
                    statics     = null;
                    target      = me;

                }

            }

        },

        // }}}
        // {{{ extend

<span id='CLI-Base-static-method-extend'>        /**
</span>         * @private
         * @static
         * @inheritable
         * @param config
         */
        extend: function(parent) {

            var me = this,
                parentPrototype = parent.prototype,
                prototype, i, ln, name, statics;

            prototype = me.prototype = CLI.Object.chain(parentPrototype);
            prototype.self = me;

            me.superclass = prototype.superclass = parentPrototype;

            if (!parent.$isClass) {

                for (i in BasePrototype) {

                    if (i in prototype) {

                        prototype[i] = BasePrototype[i];

                    }

                }

            }

            // Statics inheritance
            statics = parentPrototype.$inheritableStatics;

            if (statics) {

                for (i = 0,ln = statics.length; i &lt; ln; i++) {

                    name = statics[i];

                    if (!me.hasOwnProperty(name)) {

                        me[name] = parent[name];

                    }

                }

            }

            if (parent.$onExtended) {

                me.$onExtended = parent.$onExtended.slice();

            }

            me.getConfigurator();
        },

        // }}}
        // {{{ $onExtended

<span id='CLI-Base-static-property-S-onExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        $onExtended: [],

        // }}}
        // {{{ triggerExtended

<span id='CLI-Base-static-method-triggerExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        triggerExtended: function() {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(this, &#39;CLI.Base#triggerExtended&#39;, arguments);

            var callbacks = this.$onExtended,
                ln = callbacks.length,
                i, callback;

            if (ln &gt; 0) {

                for (i = 0; i &lt; ln; i++) {

                    callback = callbacks[i];
                    callback.fn.apply(callback.scope || this, arguments);

                }

            }

        },

        // }}}
        // {{{ onExtended

<span id='CLI-Base-static-method-onExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        onExtended: function(fn, scope) {

            this.$onExtended.push({
                fn: fn,
                scope: scope
            });

            return this;
        },

        // }}}
        // {{{ addStatics

<span id='CLI-Base-static-method-addStatics'>        /**
</span>         * Add / override static properties of this class.
         *
         *     CLI.define(&#39;My.cool.Class&#39;, {
         *         ...
         *     });
         *
         *     My.cool.Class.addStatics({
         *         someProperty: &#39;someValue&#39;,      // My.cool.Class.someProperty = &#39;someValue&#39;
         *         method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
         *         method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
         *     });
         *
         * @param {Object} members
         * @return {CLI.Base} this
         * @static
         * @inheritable
         */
        addStatics: function (members) {

            this.addMembers(members, true);

            return this;

        },

        // }}}
        // {{{ addInheritableStatics

<span id='CLI-Base-static-method-addInheritableStatics'>        /**
</span>         * @private
         * @static
         * @inheritable
         * @param {Object} members
         */
        addInheritableStatics: function(members) {

            var inheritableStatics,
                hasInheritableStatics,
                prototype = this.prototype,
                name, member;

            inheritableStatics = prototype.$inheritableStatics;
            hasInheritableStatics = prototype.$hasInheritableStatics;

            if (!inheritableStatics) {

                inheritableStatics = prototype.$inheritableStatics = [];
                hasInheritableStatics = prototype.$hasInheritableStatics = {};

            }

            var className = CLI.getClassName(this) + &#39;.&#39;;

            for (name in members) {

                if (members.hasOwnProperty(name)) {

                    member = members[name];

                    if (typeof member == &#39;function&#39;) {
                        member.displayName = className + name;
                    }

                    this[name] = member;

                    if (!hasInheritableStatics[name]) {

                        hasInheritableStatics[name] = true;
                        inheritableStatics.push(name);

                    }

                }

            }

            return this;

        },

        // }}}
        // {{{ addMembers

<span id='CLI-Base-static-method-addMembers'>        /**
</span>         * Add methods / properties to the prototype of this class.
         *
         *     CLI.define(&#39;My.awesome.Cat&#39;, {
         *         constructor: function() {
         *             ...
         *         }
         *     });
         *
         *      My.awesome.Cat.addMembers({
         *          meow: function() {
         *             alert(&#39;Meowww...&#39;);
         *          }
         *      });
         *
         *      var kitty = new My.awesome.Cat();
         *      kitty.meow();
         *
         * @param {Object} members The members to add to this class.
         * @param {Boolean} [isStatic=false] Pass `true` if the members are static.
         * @param {Boolean} [privacy=false] Pass `true` if the members are private. This
         * only has meaning in debug mode and only for methods.
         * @static
         * @inheritable
         */
        addMembers: function (members, isStatic, privacy) {

            var me = this, // this class
                cloneFunction = CLI.Function.clone,
                target = isStatic ? me : me.prototype,
                defaultConfig = !isStatic &amp;&amp; target.defaultConfig,
                enumerables = CLI.enumerables,
                privates = members.privates,
                configs, i, ln, member, name, subPrivacy, privateStatics;

            var displayName = (me.$className || &#39;&#39;) + &#39;#&#39;;

            if (privates) {

                // This won&#39;t run for normal class private members but will pick up all
                // others (statics, overrides, etc).
                delete members.privates;

                if (!isStatic) {
                    privateStatics = privates.statics;
                    delete privates.statics;
                }

                subPrivacy = privates.privacy || privacy || &#39;framework&#39;;

                me.addMembers(privates, isStatic, subPrivacy);

                if (privateStatics) {

                    me.addMembers(privateStatics, true, subPrivacy);

                }

            }

            for (name in members) {

                if (members.hasOwnProperty(name)) {

                    member = members[name];

                    if (member &amp;&amp; member.$nullFn &amp;&amp; privacy !== member.$privacy) {

                        CLI.Error.raise(&#39;Cannot use stock function for private method &#39; + (me.$className ? me.$className + &#39;#&#39; : &#39;&#39;) + name);

                    }

                    if (typeof member === &#39;function&#39; &amp;&amp; !member.$isClass &amp;&amp; !member.$nullFn) {

                        if (member.$owner) {

                            member = cloneFunction(member);

                        }

                        if (target.hasOwnProperty(name)) {

                            member.$previous = target[name];

                        }

                        // This information is needed by callParent() and callSuper() as
                        // well as statics() and even CLI.fly().
                        member.$owner = me;
                        member.$name = name;

                        member.displayName = displayName + name;

                        var existing = target[name];

                        if (privacy) {

                            if (privacy === true) {
                                privacy = &#39;framework&#39;;
                            }

                            member.$privacy = privacy;

                            // The general idea here is that an existing, non-private
                            // method can be marked private. This is because the other
                            // way is strictly forbidden (private method going public)
                            // so if a method is in that gray area it can only be made
                            // private in doc form which allows a derived class to make
                            // it public.
                            if (existing &amp;&amp; existing.$privacy &amp;&amp; existing.$privacy !== privacy) {

                                CLI.privacyViolation(me, existing, member, isStatic);

                            }

                        } else if (existing &amp;&amp; existing.$privacy) {

                            CLI.privacyViolation(me, existing, member, isStatic);

                        }

                        // The last part of the check here resolves a conflict if we have the same property
                        // declared as both a config and a member on the class so that the config wins.

                    } else if (defaultConfig &amp;&amp; (name in defaultConfig) &amp;&amp; !target.config.hasOwnProperty(name)) {

                        // This is a config property so it must be added to the configs
                        // collection not just smashed on the prototype...
                        (configs || (configs = {}))[name] = member;
                        continue;

                    }

                    target[name] = member;
                }

            }

            if (configs) {

                // Add any configs found in the normal members arena:
                me.addConfig(configs);

            }

            if (enumerables) {

                for (i = 0, ln = enumerables.length; i &lt; ln; ++i) {

                    if (members.hasOwnProperty(name = enumerables[i])) {

                        member = members[name];

                        // The enumerables are all functions...
                        if (member &amp;&amp; !member.$nullFn) {

                            if (member.$owner) {

                                member = cloneFunction(member);

                            }

                            member.$owner = me;
                            member.$name = name;
                            member.displayName = displayName + name;

                            if (target.hasOwnProperty(name)) {

                                member.$previous = target[name];

                            }

                        }

                        target[name] = member;

                    }

                }

            }

            return this;

        },

        // }}}
        // {{{ addMember

<span id='CLI-Base-static-method-addMember'>        /**
</span>         * @private
         * @static
         * @inheritable
         * @param name
         * @param member
         */
        addMember: function (name, member) {

            oneMember[name] = member;
            this.addMembers(oneMember);
            delete oneMember[name];

            return this;

        },

        // }}}
        // {{{ borrow

<span id='CLI-Base-static-method-borrow'>        /**
</span>         * Borrow another class&#39; members to the prototype of this class.
         *
         *     CLI.define(&#39;Bank&#39;, {
         *         money: &#39;$$$&#39;,
         *         printMoney: function() {
         *             alert(&#39;$$$$$$$&#39;);
         *         }
         *     });
         *
         *     CLI.define(&#39;Thief&#39;, {
         *         ...
         *     });
         *
         *     Thief.borrow(Bank, [&#39;money&#39;, &#39;printMoney&#39;]);
         *
         *     var steve = new Thief();
         *
         *     alert(steve.money); // alerts &#39;$$$&#39;
         *     steve.printMoney(); // alerts &#39;$$$$$$$&#39;
         *
         * @param {CLI.Base} fromClass The class to borrow members from
         * @param {Array/String} members The names of the members to borrow
         * @return {CLI.Base} this
         * @static
         * @inheritable
         * @private
         */
        borrow: function(fromClass, members) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(this, &#39;CLI.Base#borrow&#39;, arguments);

            var prototype = fromClass.prototype,
                membersObj = {},
                i, ln, name;

            members = CLI.Array.from(members);

            for (i = 0,ln = members.length; i &lt; ln; i++) {

                name = members[i];
                membersObj[name] = prototype[name];

            }

            return this.addMembers(membersObj);
        },

        // }}}
        // {{{ override

<span id='CLI-Base-static-method-override'>        /**
</span>         * Override members of this class. Overridden methods can be invoked via
         * {@link CLI.Base#callParent}.
         *
         *     CLI.define(&#39;My.Cat&#39;, {
         *         constructor: function() {
         *             alert(&quot;I&#39;m a cat!&quot;);
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert(&quot;I&#39;m going to be a cat!&quot;);
         *
         *             this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
         *                               // alerts &quot;I&#39;m a cat!&quot;
         *                               // alerts &quot;Meeeeoooowwww&quot;
         *
         * Direct use of this method should be rare. Use {@link CLI#define CLI.define}
         * instead:
         *
         *     CLI.define(&#39;My.CatOverride&#39;, {
         *         override: &#39;My.Cat&#39;,
         *         constructor: function() {
         *             alert(&quot;I&#39;m going to be a cat!&quot;);
         *
         *             this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *         }
         *     });
         *
         * The above accomplishes the same result but can be managed by the {@link CLI.Loader}
         * which can properly order the override and its target class and the build process
         * can determine whether the override is needed based on the required state of the
         * target class (My.Cat).
         *
         * @param {Object} members The properties to add to this class. This should be
         * specified as an object literal containing one or more properties.
         * @return {CLI.Base} this class
         * @static
         * @inheritable
         */
        override: function(members) {

            var me = this,
                statics = members.statics,
                inheritableStatics = members.inheritableStatics,
                config = members.config,
                mixins = members.mixins,
                cachedConfig = members.cachedConfig;

            if (statics || inheritableStatics || config) {

                members = CLI.apply({}, members);

            }

            if (statics) {

                me.addMembers(statics, true);
                delete members.statics;

            }

            if (inheritableStatics){

                me.addInheritableStatics(inheritableStatics);
                delete members.inheritableStatics;

            }

            if (config) {

                me.addConfig(config);
                delete members.config;

            }

            if (cachedConfig) {

                me.addCachedConfig(cachedConfig);
                delete members.cachedConfig;

            }

            delete members.mixins;

            me.addMembers(members);

            if (mixins) {

                me.mixin(mixins);

            }

            return me;

        },

        // }}}
        // {{{ callParent

<span id='CLI-Base-static-method-callParent'>        /**
</span>         * @protected
         * @static
         * @inheritable
         */
        callParent: function(args) {

            var method;

            // This code is intentionally inlined for the least amount of debugger stepping
            return (method = this.callParent.caller) &amp;&amp; (method.$previous || ((method = method.$owner ? method : method.caller) &amp;&amp; method.$owner.superclass.self[method.$name])).apply(this, args || noArgs);

        },

        // }}}
        // {{{ callSuper

<span id='CLI-Base-static-method-callSuper'>        /**
</span>         * @protected
         * @static
         * @inheritable
         */
        callSuper: function(args) {

            var method;

            // This code is intentionally inlined for the least amount of debugger stepping
            return (method = this.callSuper.caller) &amp;&amp; ((method = method.$owner ? method : method.caller) &amp;&amp; method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);

        },

        // }}}
        // {{{ mixin

<span id='CLI-Base-static-method-mixin'>        /**
</span>         * Used internally by the mixins pre-processor
         * @private
         * @static
         * @inheritable
         */
        mixin: function(name, mixinClass) {

            var me = this,
                mixin, prototype, key, statics, i, ln, staticName, mixinValue, mixins;

            if (typeof name !== &#39;string&#39;) {

                mixins = name;

                if (mixins instanceof Array) {

                    for (i = 0,ln = mixins.length; i &lt; ln; i++) {

                        mixin = mixins[i];
                        me.mixin(mixin.prototype.mixinId || mixin.$className, mixin);

                    }

                } else {

                    // Not a string or array - process the object form:
                    // mixins: {
                    //     foo: ...
                    // }
                    for (var mixinName in mixins) {

                        me.mixin(mixinName, mixins[mixinName]);

                    }

                }

                return;

            }

            mixin = mixinClass.prototype;
            prototype = me.prototype;

            if (mixin.onClassMixedIn) {

                mixin.onClassMixedIn.call(mixinClass, me);

            }

            if (!prototype.hasOwnProperty(&#39;mixins&#39;)) {

                if (&#39;mixins&#39; in prototype) {

                    prototype.mixins = CLI.Object.chain(prototype.mixins);

                } else {

                    prototype.mixins = {};

                }

            }

            for (key in mixin) {

                mixinValue = mixin[key];

                if (key === &#39;mixins&#39;) {

                    // if 2 superclasses (e.g. a base class and a mixin) of this class both
                    // have a mixin with the same id, the first one wins, that is to say,
                    // the first mixin&#39;s methods to be applied to the prototype will not
                    // be overwritten by the second one.  Since this is the case we also
                    // want to make sure we use the first mixin&#39;s prototype as the mixin
                    // reference, hence the &quot;applyIf&quot; below.  A real world example of this
                    // is CLI.Widget which mixes in CLI.mixin.Observable.  CLI.Widget can
                    // be mixed into subclasses of CLI.Component, which mixes in
                    // CLI.util.Observable.  In this example, since the first &quot;observable&quot;
                    // mixin&#39;s methods win, we also want its reference to be preserved.
                    CLI.applyIf(prototype.mixins, mixinValue);

                } else if (!(key === &#39;mixinId&#39; || key === &#39;config&#39;) &amp;&amp; (prototype[key] === undefined)) {

                    prototype[key] = mixinValue;

                }

            }

            // Mixin statics inheritance
            statics = mixin.$inheritableStatics;

            if (statics) {

                for (i = 0, ln = statics.length; i &lt; ln; i++) {

                    staticName = statics[i];

                    if (!me.hasOwnProperty(staticName)) {

                        me[staticName] = mixinClass[staticName];

                    }

                }

            }

            if (&#39;config&#39; in mixin) {

                me.addConfig(mixin.config, mixinClass);

            }

            prototype.mixins[name] = mixin;

            if (mixin.afterClassMixedIn) {

                mixin.afterClassMixedIn.call(mixinClass, me);

            }

            return me;

        },

        // }}}
        // {{{ addConfig

<span id='CLI-Base-static-method-addConfig'>        /**
</span>         * Adds new config properties to this class. This is called for classes when they
         * are declared, then for any mixins that class may define and finally for any
         * overrides defined that target the class.
         *
         * @param {Object} config
         * @param {Class} [mixinClass] The mixin class if the configs are from a mixin.
         * @private
         * @static
         * @inheritable
         */
        addConfig: function (config, mixinClass) {

            var cfg = this.$config || this.getConfigurator();

            cfg.add(config, mixinClass);

        },

        // }}}
        // {{{ addCachedConfig

        addCachedConfig: function(config, isMixin) {

            var cached = {}, key;

            for (key in config) {

                cached[key] = {
                    cached: true,
                    $value: config[key]
                };

            }

            this.addConfig(cached, isMixin);

        },

        // }}}
        // {{{ getConfigurator

<span id='CLI-Base-static-method-getConfigurator'>        /**
</span>         * Returns the `CLI.Configurator` for this class.
         *
         * @return {CLI.Configurator}
         * @private
         * @static
         * @inheritable
         */
        getConfigurator: function () {

            // the CLI.Configurator ctor will set $config so micro-opt out fn call:
            return this.$config || new CLI.Configurator(this);

        },

        // }}}
        // {{{ getName

<span id='CLI-Base-static-method-getName'>        /**
</span>         * Get the current class&#39; name in string format.
         *
         *     CLI.define(&#39;My.cool.Class&#39;, {
         *         constructor: function() {
         *             alert(this.self.getName()); // alerts &#39;My.cool.Class&#39;
         *         }
         *     });
         *
         *     My.cool.Class.getName(); // &#39;My.cool.Class&#39;
         *
         * @return {String} className
         * @static
         * @inheritable
         */
        getName: function() {

            return CLI.getClassName(this);

        },

        // }}}
        // {{{ createAlias

<span id='CLI-Base-static-method-createAlias'>        /**
</span>         * Create aliases for existing prototype methods. Example:
         *
         *     CLI.define(&#39;My.cool.Class&#39;, {
         *         method1: function() { ... },
         *         method2: function() { ... }
         *     });
         *
         *     var test = new My.cool.Class();
         *
         *     My.cool.Class.createAlias({
         *         method3: &#39;method1&#39;,
         *         method4: &#39;method2&#39;
         *     });
         *
         *     test.method3(); // test.method1()
         *
         *     My.cool.Class.createAlias(&#39;method5&#39;, &#39;method3&#39;);
         *
         *     test.method5(); // test.method3() -&gt; test.method1()
         *
         * @param {String/Object} alias The new method name, or an object to set multiple aliases. See
         * {@link CLI.Function#flexSetter flexSetter}
         * @param {String/Object} origin The original method name
         * @static
         * @inheritable
         * @method
         */
        createAlias: flexSetter(function(alias, origin) {

            aliasOneMember[alias] = function() {

                return this[origin].apply(this, arguments);

            };

            this.override(aliasOneMember);

            delete aliasOneMember[alias];
        })

        // }}}

    });

    // Capture the set of static members on CLI.Base that we want to copy to all
    // derived classes. This array is used by CLI.Class as well as the optimizer.
    for (baseStaticMember in Base) {

        if (Base.hasOwnProperty(baseStaticMember)) {

            baseStaticMembers.push(baseStaticMember);

        }

    }

    Base.$staticMembers = baseStaticMembers;

    Base.getConfigurator(); // lazily create now so as not capture in $staticMembers

    Base.addMembers({

        // {{{ $className

<span id='CLI-Base-property-S-className'>        /** @private */
</span>        $className: &#39;CLI.Base&#39;,

        // }}}
        // {{{ isInstance

<span id='CLI-Base-property-isInstance'>        /**
</span>         * @property {Boolean} isInstance
         * This value is `true` and is used to identify plain objects from instances of
         * a defined class.
         * @protected
         * @readonly
         */
        isInstance: true,

        // }}}
        // {{{ $configPrefixed

<span id='CLI-Base-property-S-configPrefixed'>        /**
</span>         * @property {Boolean} [$configPrefixed=false]
         * The value `true` causes `config` values to be stored on instances using a
         * property name prefixed with an underscore (&quot;_&quot;) character. A value of `false`
         * stores `config` values as properties using their exact name (no prefix).
         * @private
         */
        $configPrefixed: true,

        // }}}
        // {{{ $configStrict

<span id='CLI-Base-property-S-configStrict'>        /**
</span>         * @property {Boolean} [$configStrict=true]
         * The value `true` instructs the `initConfig` method to only honor values for
         * properties declared in the `config` block of a class. When `false`, properties
         * that are not declared in a `config` block will be placed on the instance.
         * @private
         */
        $configStrict: true,

        // }}}
        // {{{ isConfiguring

<span id='CLI-Base-property-isConfiguring'>        /**
</span>         * @property {Boolean} isConfiguring
         * This property is set to `true` during the call to `initConfig`.
         * @protected
         * @readonly
         */
        isConfiguring: false,

        // }}}
        // {{{ isFirstInstance

<span id='CLI-Base-property-isFirstInstance'>        /**
</span>         * @property {Boolean} isFirstInstance
         * This property is set to `true` if this instance is the first of its class.
         * @protected
         * @readonly
         */
        isFirstInstance: false,

        // }}}
        // {{{ statics

<span id='CLI-Base-method-statics'>        /**
</span>         * Get the reference to the class from which this object was instantiated. Note that unlike {@link CLI.Base#self},
         * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
         * `this` points to during run-time
         *
         *     CLI.define(&#39;My.Cat&#39;, {
         *         statics: {
         *             totalCreated: 0,
         *             speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
         *         },
         *
         *         constructor: function() {
         *             var statics = this.statics();
         *
         *             alert(statics.speciesName);     // always equals to &#39;Cat&#39; no matter what &#39;this&#39; refers to
         *                                             // equivalent to: My.Cat.speciesName
         *
         *             alert(this.self.speciesName);   // dependent on &#39;this&#39;
         *
         *             statics.totalCreated++;
         *         },
         *
         *         clone: function() {
         *             var cloned = new this.self();   // dependent on &#39;this&#39;
         *
         *             cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
         *
         *             return cloned;
         *         }
         *     });
         *
         *
         *     CLI.define(&#39;My.SnowLeopard&#39;, {
         *         extend: &#39;My.Cat&#39;,
         *
         *         statics: {
         *             speciesName: &#39;Snow Leopard&#39;     // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
         *         },
         *
         *         constructor: function() {
         *             this.callParent();
         *         }
         *     });
         *
         *     var cat = new My.Cat();                 // alerts &#39;Cat&#39;, then alerts &#39;Cat&#39;
         *
         *     var snowLeopard = new My.SnowLeopard(); // alerts &#39;Cat&#39;, then alerts &#39;Snow Leopard&#39;
         *
         *     var clone = snowLeopard.clone();
         *     alert(CLI.getClassName(clone));         // alerts &#39;My.SnowLeopard&#39;
         *     alert(clone.groupName);                 // alerts &#39;Cat&#39;
         *
         *     alert(My.Cat.totalCreated);             // alerts 3
         *
         * @protected
         * @return {CLI.Class}
         */
        statics: function() {

            var method = this.statics.caller,
                self = this.self;

            if (!method) {
                return self;
            }

            return method.$owner;

        },

        // }}}
        // {{{ callParent

<span id='CLI-Base-method-callParent'>        /**
</span>         * Call the &quot;parent&quot; method of the current method. That is the method previously
         * overridden by derivation or by an override (see {@link CLI#define}).
         *
         *      CLI.define(&#39;My.Base&#39;, {
         *          constructor: function (x) {
         *              this.x = x;
         *          },
         *
         *          statics: {
         *              method: function (x) {
         *                  return x;
         *              }
         *          }
         *      });
         *
         *      CLI.define(&#39;My.Derived&#39;, {
         *          extend: &#39;My.Base&#39;,
         *
         *          constructor: function () {
         *              this.callParent([21]);
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // alerts 21
         *
         * This can be used with an override as follows:
         *
         *      CLI.define(&#39;My.DerivedOverride&#39;, {
         *          override: &#39;My.Derived&#39;,
         *
         *          constructor: function (x) {
         *              this.callParent([x*2]); // calls original My.Derived constructor
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // now alerts 42
         *
         * This also works with static methods.
         *
         *      CLI.define(&#39;My.Derived2&#39;, {
         *          extend: &#39;My.Base&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Base.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Base.method(10));     // alerts 10
         *      alert(My.Derived2.method(10)); // alerts 20
         *
         * Lastly, it also works with overridden static methods.
         *
         *      CLI.define(&#39;My.Derived2Override&#39;, {
         *          override: &#39;My.Derived2&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Derived2.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Derived2.method(10); // now alerts 40
         *
         * To override a method and replace it and also call the superclass method, use
         * {@link #callSuper}. This is often done to patch a method to fix a bug.
         *
         * @protected
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callParent(arguments)`
         * @return {Object} Returns the result of calling the parent method
         */
        callParent: function(args) {

            // NOTE: this code is deliberately as few expressions (and no function calls)
            // as possible so that a debugger can skip over this noise with the minimum number
            // of steps. Basically, just hit Step Into until you are where you really wanted
            // to be.
            var method,
                superMethod = (method = this.callParent.caller) &amp;&amp; (method.$previous || ((method = method.$owner ? method : method.caller) &amp;&amp; method.$owner.superclass[method.$name]));

            if (!superMethod) {

                method = this.callParent.caller;

                var parentClass, methodName;

                if (!method.$owner) {

                    if (!method.caller) {

                        throw new Error(&quot;Attempting to call a protected method from the public scope, which is not allowed&quot;);

                    }

                    method = method.caller;

                }

                parentClass = method.$owner.superclass;
                methodName = method.$name;

                if (!(methodName in parentClass)) {

                    throw new Error(&quot;this.callParent() was called but there&#39;s no such method (&quot; + methodName + &quot;) found in the parent class (&quot; + (CLI.getClassName(parentClass) || &#39;Object&#39;) + &quot;)&quot;);

                }

            }

            return superMethod.apply(this, args || noArgs);

        },

        // }}}
        // {{{ callSuper

<span id='CLI-Base-method-callSuper'>        /**
</span>         * This method is used by an override to call the superclass method but bypass any
         * overridden method. This is often done to &quot;patch&quot; a method that contains a bug
         * but for whatever reason cannot be fixed directly.
         *
         * Consider:
         *
         *      CLI.define(&#39;CLI.some.Class&#39;, {
         *          method: function () {
         *              console.log(&#39;Good&#39;);
         *          }
         *      });
         *
         *      CLI.define(&#39;CLI.some.DerivedClass&#39;, {
         *          extend: &#39;CLI.some.Class&#39;,
         *
         *          method: function () {
         *              console.log(&#39;Bad&#39;);
         *
         *              // ... logic but with a bug ...
         *
         *              this.callParent();
         *          }
         *      });
         *
         * To patch the bug in `CLI.some.DerivedClass.method`, the typical solution is to create an
         * override:
         *
         *      CLI.define(&#39;App.patches.DerivedClass&#39;, {
         *          override: &#39;CLI.some.DerivedClass&#39;,
         *
         *          method: function () {
         *              console.log(&#39;Fixed&#39;);
         *
         *              // ... logic but with bug fixed ...
         *
         *              this.callSuper();
         *          }
         *      });
         *
         * The patch method cannot use `callParent` to call the superclass `method` since
         * that would call the overridden method containing the bug. In other words, the
         * above patch would only produce &quot;Fixed&quot; then &quot;Good&quot; in the console log, whereas,
         * using `callParent` would produce &quot;Fixed&quot; then &quot;Bad&quot; then &quot;Good&quot;.
         *
         * @protected
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callSuper(arguments)`
         * @return {Object} Returns the result of calling the superclass method
         */
        callSuper: function(args) {

            // NOTE: this code is deliberately as few expressions (and no function calls)
            // as possible so that a debugger can skip over this noise with the minimum number
            // of steps. Basically, just hit Step Into until you are where you really wanted
            // to be.
            var method,
                superMethod = (method = this.callSuper.caller) &amp;&amp; ((method = method.$owner ? method : method.caller) &amp;&amp; method.$owner.superclass[method.$name]);

            if (!superMethod) {

                method = this.callSuper.caller;

                var parentClass, methodName;

                if (!method.$owner) {

                    if (!method.caller) {

                        throw new Error(&quot;Attempting to call a protected method from the public scope, which is not allowed&quot;);

                    }

                    method = method.caller;
                }

                parentClass = method.$owner.superclass;
                methodName = method.$name;

                if (!(methodName in parentClass)) {

                    throw new Error(&quot;this.callSuper() was called but there&#39;s no such method (&quot; + methodName + &quot;) found in the parent class (&quot; + (CLI.getClassName(parentClass) || &#39;Object&#39;) + &quot;)&quot;);

                }

            }

            return superMethod.apply(this, args || noArgs);

        },

        // }}}
        // {{{ self

<span id='CLI-Base-property-self'>        /**
</span>         * @property {CLI.Class} self
         *
         * Get the reference to the current class from which this object was instantiated. Unlike {@link CLI.Base#statics},
         * `this.self` is scope-dependent and it&#39;s meant to be used for dynamic inheritance. See {@link CLI.Base#statics}
         * for a detailed comparison
         *
         *     CLI.define(&#39;My.Cat&#39;, {
         *         statics: {
         *             speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
         *         },
         *
         *         constructor: function() {
         *             alert(this.self.speciesName); // dependent on &#39;this&#39;
         *         },
         *
         *         clone: function() {
         *             return new this.self();
         *         }
         *     });
         *
         *
         *     CLI.define(&#39;My.SnowLeopard&#39;, {
         *         extend: &#39;My.Cat&#39;,
         *         statics: {
         *             speciesName: &#39;Snow Leopard&#39;         // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
         *         }
         *     });
         *
         *     var cat = new My.Cat();                     // alerts &#39;Cat&#39;
         *     var snowLeopard = new My.SnowLeopard();     // alerts &#39;Snow Leopard&#39;
         *
         *     var clone = snowLeopard.clone();
         *     alert(CLI.getClassName(clone));             // alerts &#39;My.SnowLeopard&#39;
         *
         * @protected
         */
        self: Base,

        // }}}
        // {{{ constructor

        // Default constructor, simply returns `this`
        constructor: function() {

            return this;

        },

        // }}}
        // {{{ getConfigurator

        getConfigurator: function () {

            return this.$config || this.self.getConfigurator();

        },

        // }}}
        // {{{ initConfig

<span id='CLI-Base-method-initConfig'>        /**
</span>         * Initialize configuration for this class. a typical example:
         *
         *     CLI.define(&#39;My.awesome.Class&#39;, {
         *         // The default config
         *         config: {
         *             name: &#39;Awesome&#39;,
         *             isAwesome: true
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *         }
         *     });
         *
         *     var awesome = new My.awesome.Class({
         *         name: &#39;Super Awesome&#39;
         *     });
         *
         *     alert(awesome.getName()); // &#39;Super Awesome&#39;
         *
         * @protected
         * @param {Object} config
         * @return {CLI.Base} this
         */
        initConfig: function(instanceConfig) {

            var me = this,
                cfg = me.getConfigurator();

            me.initConfig = CLI.emptyFn; // ignore subsequent calls to initConfig
            me.initialConfig = instanceConfig || {};
            cfg.configure(me, instanceConfig);

            return me;
        },

        // }}}
        // {{{ beforeInitConfig

        beforeInitConfig: CLI.emptyFn,

        // }}}
        // {{{ getConfig

<span id='CLI-Base-method-getConfig'>        /**
</span>         * Returns a specified config property value. If the name parameter is not passed,
         * all current configuration options will be returned as key value pairs.
         * @method
         * @param {String} [name] The name of the config property to get.
         * @param {Boolean} [peek=false] `true` to peek at the raw value without calling the getter.
         * @return {Object} The config property value.
         */
        getConfig: getConfig,

        // }}}
        // {{{ setConfig

<span id='CLI-Base-method-setConfig'>        /**
</span>         * Sets a single/multiple configuration options.
         * @method
         * @param {String/Object} name The name of the property to set, or a set of key value pairs to set.
         * @param {Object} [value] The value to set for the name parameter.
         * @return {CLI.Base} this
         */
        setConfig: function(name, value, /* private */ options) {

            // options can have the following properties:
            // - defaults `true` to only set the config(s) that have not been already set on
            // this instance.
            // - strict `false` to apply properties to the instance that are not configs,
            // and do not have setters.
            var me = this, config;

            if (name) {

                if (typeof name === &#39;string&#39;) {

                    config = {};
                    config[name] = value;

                } else {

                    config = name;

                }

                me.getConfigurator().reconfigure(me, config, options);

            }

            return me;
        },

        // }}}
        // {{{ getCurrentConfig

<span id='CLI-Base-method-getCurrentConfig'>        /**
</span>         * @private
         */
        getCurrentConfig: function() {

            var cfg = this.getConfigurator();

            return cfg.getCurrentConfig(this);

        },

        // }}}
        // {{{ hasConfig

<span id='CLI-Base-method-hasConfig'>        /**
</span>         * @private
         * @param config
         */
        hasConfig: function(name) {

            return name in this.defaultConfig;

        },

        // }}}
        // {{{ getInitialConfig

<span id='CLI-Base-method-getInitialConfig'>        /**
</span>         * Returns the initial configuration passed to constructor when instantiating
         * this class.
         * @param {String} [name] Name of the config option to return.
         * @return {Object/Mixed} The full config object or a single config value
         * when `name` parameter specified.
         */
        getInitialConfig: function(name) {

            var config = this.config;

            if (!name) {

                return config;

            }

            return config[name];

        },

        // }}}
        // {{{ $links

        $links: null,

        // }}}
        // {{{ link

<span id='CLI-Base-method-link'>        /**
</span>         * Adds a &quot;destroyable&quot; object to an internal list of objects that will be destroyed
         * when this instance is destroyed (via `{@link #destroy}`).
         * @param {String} name
         * @param {Object} value
         * @return {Object} The `value` passed.
         * @private
         */
        link: function (name, value) {

            var me = this,
                links = me.$links || (me.$links = {});

            links[name] = true;
            me[name] = value;

            return value;
        },

        // }}}
        // {{{ unlink

<span id='CLI-Base-method-unlink'>        /**
</span>         * Destroys a given set of `{@link #link linked}` objects. This is only needed if
         * the linked object is being destroyed before this instance.
         * @param {String[]} names The names of the linked objects to destroy.
         * @return {CLI.Base} this
         * @private
         */
        unlink: function (names) {

            var me = this,
                i, ln, link, value;

            if (!CLI.isArray(names)) {

                CLI.Error.raise(&#39;Invalid argument - expected array of strings&#39;);

            }

            for (i = 0, ln = names.length; i &lt; ln; i++) {

                link = names[i];
                value = me[link];

                if (value) {

                    if (value.isInstance &amp;&amp; !value.isDestroyed) {

                        value.destroy();

                    } else if (value.parentNode &amp;&amp; &#39;nodeType&#39; in value) {

                        value.parentNode.removeChild(value);

                    }

                }

                me[link] = null;
            }

            return me;
        },

        // }}}
        // {{{ destroy

<span id='CLI-Base-method-destroy'>        /**
</span>         * This method is called to cleanup an object and its resources. After calling
         * this method, the object should not be used any further.
         * @protected
         */
        destroy: function() {

            var me = this,
                links = me.$links;

            me.destroy = CLI.emptyFn;
            me.isDestroyed = true;

            if (links) {

                me.$links = null;
                me.unlink(CLI.Object.getKeys(links));

            }

        }

        // }}}

    });

    // {{{ callOverridden

<span id='CLI-Base-method-callOverridden'>    /**
</span>     * Call the original method that was previously overridden with {@link CLI.Base#override}
     *
     *     CLI.define(&#39;My.Cat&#39;, {
     *         constructor: function() {
     *             alert(&quot;I&#39;m a cat!&quot;);
     *         }
     *     });
     *
     *     My.Cat.override({
     *         constructor: function() {
     *             alert(&quot;I&#39;m going to be a cat!&quot;);
     *
     *             this.callOverridden();
     *
     *             alert(&quot;Meeeeoooowwww&quot;);
     *         }
     *     });
     *
     *     var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
     *                               // alerts &quot;I&#39;m a cat!&quot;
     *                               // alerts &quot;Meeeeoooowwww&quot;
     *
     * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
     * from the current method, for example: `this.callOverridden(arguments)`
     * @return {Object} Returns the result of calling the overridden method
     * @protected
     * @deprecated Use {@link #callParent} instead.
     */
    BasePrototype.callOverridden = BasePrototype.callParent;

    // }}}
    // {{{  CLI.privacyViolation

    CLI.privacyViolation = function (cls, existing, member, isStatic) {

        var name = member.$name,
            conflictCls = existing.$owner &amp;&amp; existing.$owner.$className,
            s = isStatic ? &#39;static &#39; : &#39;&#39;,
            msg = member.$privacy
                ? &#39;Private &#39; + s + member.$privacy + &#39; method &quot;&#39; + name + &#39;&quot;&#39;
                : &#39;Public &#39; + s + &#39;method &quot;&#39; + name + &#39;&quot;&#39;;

        if (cls.$className) {

            msg = cls.$className + &#39;: &#39; + msg;

        }

        if (!existing.$privacy) {

            msg += conflictCls
                ? &#39; hides public method inherited from &#39; + conflictCls
                : &#39; hides inherited public method.&#39;;

        } else {

            msg += conflictCls
                ? &#39; conflicts with private &#39; + existing.$privacy + &#39; method declared by &#39; + conflictCls
                : &#39; conflicts with inherited private &#39; + existing.$privacy + &#39; method.&#39;;

        }

        var compat = CLI.getCompatVersion();
        var ver = CLI.getVersion();

        // When compatibility is enabled, log problems instead of throwing errors.
        if (ver &amp;&amp; compat &amp;&amp; compat.lt(ver)) {

            CLI.log.error(msg);

        } else {

            CLI.Error.raise(msg);

        }

    };

    // }}}

    return Base;

}(CLI.Function.flexSetter));

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
