<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * This file is part of CLI Framework
 */

<span id='CLI-util-Format'>/**
</span> * @class CLI.util.Format
 *
 * This class is a centralized place for formatting functions. It includes
 * functions to format various different types of data, such as text, dates and numeric values.
 *
 * ## Localization
 *
 * This class contains several options for localization. These can be set once the library has loaded,
 * all calls to the functions from that point will use the locale settings that were specified.
 *
 * Options include:
 *
 * - thousandSeparator
 * - decimalSeparator
 * - currenyPrecision
 * - currencySign
 * - currencyAtEnd
 *
 * This class also uses the default date format defined here: {@link CLI.Date#defaultFormat}.
 *
 * ## Using with renderers
 *
 * There are two helper functions that return a new function that can be used in conjunction with
 * grid renderers:
 *
 *     columns: [{
 *         dataIndex: &#39;date&#39;,
 *         renderer: CLI.util.Format.dateRenderer(&#39;Y-m-d&#39;)
 *     }, {
 *         dataIndex: &#39;time&#39;,
 *         renderer: CLI.util.Format.numberRenderer(&#39;0.000&#39;)
 *     }]
 *
 * Functions that only take a single argument can also be passed directly:
 *
 *     columns: [{
 *         dataIndex: &#39;cost&#39;,
 *         renderer: CLI.util.Format.usMoney
 *     }, {
 *         dataIndex: &#39;productCode&#39;,
 *         renderer: CLI.util.Format.uppercase
 *     }]
 *
 * ## Using with XTemplates
 *
 * XTemplates can also directly use CLI.util.Format functions:
 *
 *     new CLI.XTemplate([
 *         &#39;Date: {startDate:date(&quot;Y-m-d&quot;)}&#39;,
 *         &#39;Cost: {cost:usMoney}&#39;
 *     ]);
 *
 * @singleton
 */
CLI.define(&#39;CLI.util.Format&#39;, function () {

    var me; // holds our singleton instance

    return {

        // {{{ requires

        requires: [
            &#39;CLI.Error&#39;,
            &#39;CLI.Number&#39;,
            &#39;CLI.String&#39;,
            &#39;CLI.Date&#39;
        ],

        // }}}
        // {{{ singleton

        singleton: true,

        // }}}
        // {{{ defaultDateFormat

<span id='CLI-util-Format-property-defaultDateFormat'>        /**
</span>         * The global default date format.
         */
        defaultDateFormat: &#39;m/d/Y&#39;,

        // }}}
        // {{{ thousandSeparator

<span id='CLI-util-Format-property-thousandSeparator'>        /**
</span>         * @property {String} thousandSeparator
         * The character that the {@link #number} function uses as a thousand separator.
         *
         * This may be overridden in a locale file.
         */
        thousandSeparator: &#39;,&#39;,

        // }}}
        // {{{ decimalSeparator

<span id='CLI-util-Format-property-decimalSeparator'>        /**
</span>         * @property {String} decimalSeparator
         * The character that the {@link #number} function uses as a decimal point.
         *
         * This may be overridden in a locale file.
         */
        decimalSeparator: &#39;.&#39;,

        // }}}
        // {{{ currencyPrecision

<span id='CLI-util-Format-property-currencyPrecision'>        /**
</span>         * @property {Number} currencyPrecision
         * The number of decimal places that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        currencyPrecision: 2,

        // }}}
        // {{{ currencySign

<span id='CLI-util-Format-property-currencySign'>        /**
</span>         * @property {String} currencySign
         * The currency sign that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        currencySign: &#39;$&#39;,

        // }}}
        // {{{ percentSign

<span id='CLI-util-Format-property-percentSign'>        /**
</span>         * @property {String} percentSign
         * The percent sign that the {@link #percent} function displays.
         *
         * This may be overridden in a locale file.
         */
        percentSign: &#39;%&#39;,

        // }}}
        // {{{ currencyAtEnd

<span id='CLI-util-Format-property-currencyAtEnd'>        /**
</span>         * @property {Boolean} currencyAtEnd
         * This may be set to &lt;code&gt;true&lt;/code&gt; to make the {@link #currency} function
         * append the currency sign to the formatted value.
         *
         * This may be overridden in a locale file.
         */
        currencyAtEnd: false,

        // }}}
        // {{{ stripTagsRe

        stripTagsRe: /&lt;\/?[^&gt;]+&gt;/gi,

        // }}}
        // {{{ stripScriptsRe

        stripScriptsRe: /(?:&lt;script.*?&gt;)((\n|\r|.)*?)(?:&lt;\/script&gt;)/ig,

        // }}}
        // {{{ nl2brRe

        nl2brRe: /\r?\n/g,

        // }}}
        // {{{ hashRe

        hashRe: /#+$/,

        // }}}
        // {{{ allHashes

        allHashes: /^#+$/,

        // }}}
        // {{{ formatPattern

        // Match a format string characters to be able to detect remaining &quot;literal&quot; characters
        formatPattern: /[\d,\.#]+/,

        // }}}
        // {{{ formatCleanRe

        // A RegExp to remove from a number format string, all characters except digits and &#39;.&#39;
        formatCleanRe: /[^\d\.#]/g,

        // }}}
        // {{{ I18NFormatCleanRe

        // A RegExp to remove from a number format string, all characters except digits and the local decimal separator.
        // Created on first use. The local decimal separator character must be initialized for this to be created.
        I18NFormatCleanRe: null,

        // }}}
        // {{{ formatFns

        // Cache ofg number formatting functions keyed by format string
        formatFns: {},

        // }}}
        // {{{ constructor

        constructor: function () {
            me = this; // we are a singleton, so cache our this pointer in scope
        },

        // }}}
        // {{{ undef

<span id='CLI-util-Format-method-undef'>        /**
</span>         * Checks a reference and converts it to empty string if it is undefined.
         * @param {Object} value Reference to check
         * @return {Object} Empty string if converted, otherwise the original value
         */
        undef : function(value) {
            return value !== undefined ? value : &quot;&quot;;
        },

        // }}}
        // {{{ defaultValue

<span id='CLI-util-Format-method-defaultValue'>        /**
</span>         * Checks a reference and converts it to the default value if it&#39;s empty.
         * @param {Object} value Reference to check
         * @param {String} [defaultValue=&quot;&quot;] The value to insert of it&#39;s undefined.
         * @return {String}
         */
        defaultValue : function(value, defaultValue) {
            return value !== undefined &amp;&amp; value !== &#39;&#39; ? value : defaultValue;
        },

        // }}}
        // {{{ substr

<span id='CLI-util-Format-method-substr'>        /**
</span>         * Returns a substring from within an original string.
         * @param {String} value The original text
         * @param {Number} start The start index of the substring
         * @param {Number} length The length of the substring
         * @return {String} The substring
         * @method
         */
        substr : function(value, start, length) {
            return String(value).substr(start, length);
        },

        // }}}
        // {{{ lowercase

<span id='CLI-util-Format-method-lowercase'>        /**
</span>         * Converts a string to all lower case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        lowercase : function(value) {
            return String(value).toLowerCase();
        },

        // }}}
        // {{{ uppercase

<span id='CLI-util-Format-method-uppercase'>        /**
</span>         * Converts a string to all upper case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        uppercase : function(value) {
            return String(value).toUpperCase();
        },

        // }}}
        // {{{ usMoney

<span id='CLI-util-Format-method-usMoney'>        /**
</span>         * Format a number as US currency.
         * @param {Number/String} value The numeric value to format
         * @return {String} The formatted currency string
         */
        usMoney : function(v) {
            return me.currency(v, &#39;$&#39;, 2);
        },

        // }}}
        // {{{ currency

<span id='CLI-util-Format-method-currency'>        /**
</span>         * Format a number as a currency.
         * @param {Number/String} value The numeric value to format
         * @param {String} [sign] The currency sign to use (defaults to {@link #currencySign})
         * @param {Number} [decimals] The number of decimals to use for the currency
         * (defaults to {@link #currencyPrecision})
         * @param {Boolean} [end] True if the currency sign should be at the end of the string
         * (defaults to {@link #currencyAtEnd})
         * @return {String} The formatted currency string
         */
        currency: function(v, currencySign, decimals, end) {

            var negativeSign = &#39;&#39;,
                format = &quot;,0&quot;,
                i = 0;

            v = v - 0;

            if (v &lt; 0) {
                v = -v;
                negativeSign = &#39;-&#39;;
            }

            decimals = CLI.isDefined(decimals) ? decimals : me.currencyPrecision;
            format += (decimals &gt; 0 ? &#39;.&#39; : &#39;&#39;);

            for (; i &lt; decimals; i++) {
                format += &#39;0&#39;;
            }

            v = me.number(v, format);

            if ((end || me.currencyAtEnd) === true) {
                return CLI.String.format(&quot;{0}{1}{2}&quot;, negativeSign, v, currencySign || me.currencySign);
            } else {
                return CLI.String.format(&quot;{0}{1}{2}&quot;, negativeSign, currencySign || me.currencySign, v);
            }

        },

        // }}}
        // {{{ date

<span id='CLI-util-Format-method-date'>        /**
</span>         * Formats the passed date using the specified format pattern.
         * Note that this uses the native Javascript Date.parse() method and is therefore subject to its idiosyncrasies.
         * Most formats assume the local timezone unless specified. One notable exception is &#39;YYYY-MM-DD&#39; (note the dashes)
         * which is typically interpreted in UTC and can cause date shifting.
         *
         * @param {String/Date} value The value to format. Strings must conform to the format
         * expected by the JavaScript Date object&#39;s
         * [parse() method](http://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse).
         * @param {String} [format] Any valid date format string. Defaults to {@link CLI.Date#defaultFormat}.
         * @return {String} The formatted date string.
         */
        date: function(v, format) {
            if (!v) {
                return &quot;&quot;;
            }
            if (!CLI.isDate(v)) {
                v = new Date(Date.parse(v));
            }
            return CLI.Date.dateFormat(v, format || CLI.Date.defaultFormat);
        },

        // }}}
        // {{{ dateRenderer

<span id='CLI-util-Format-method-dateRenderer'>        /**
</span>         * Returns a date rendering function that can be reused to apply a date format multiple times efficiently.
         * @param {String} format Any valid date format string. Defaults to {@link CLI.Date#defaultFormat}.
         * @return {Function} The date formatting function
         */
        dateRenderer : function(format) {
            return function(v) {
                return me.date(v, format);
            };
        },

        // }}}
        // {{{ hex

<span id='CLI-util-Format-method-hex'>        /**
</span>         * Returns the given number as a base 16 string at least `digits` in length. If
         * the number is fewer digits, 0&#39;s are prepended as necessary. If `digits` is
         * negative, the absolute value is the *exact* number of digits to return. In this
         * case, if then number has more digits, only the least significant digits are
         * returned.
         *
         *      expect(CLI.util.Format.hex(0x12e4, 2)).toBe(&#39;12e4&#39;);
         *      expect(CLI.util.Format.hex(0x12e4, -2)).toBe(&#39;e4&#39;);
         *      expect(CLI.util.Format.hex(0x0e, 2)).toBe(&#39;0e&#39;);
         *
         * @param {Number} value The number to format in hex.
         * @param {Number} digits
         * @returns {string}
         */
        hex: function (value, digits) {

            var s = parseInt(value || 0, 10).toString(16);

            if (digits) {

                if (digits &lt; 0) {

                    digits = -digits;

                    if (s.length &gt; digits) {

                        s = s.substring(s.length - digits);

                    }

                }

                while (s.length &lt; digits) {

                    s = &#39;0&#39; + s;

                }

            }

            return s;

        },

        // }}}
        // {{{ or

<span id='CLI-util-Format-method-or'>        /**
</span>         * Returns this result:
         *
         *      value || orValue
         *
         * The usefulness of this formatter method is in templates. For example:
         *
         *      {foo:or(&quot;bar&quot;)}
         *
         * @param {Boolean} value The &quot;if&quot; value.
         * @param {Mixed} orValue
         */
        or: function (value, orValue) {

            return value || orValue;

        },

        // }}}
        // {{{ pick

<span id='CLI-util-Format-method-pick'>        /**
</span>         * If `value` is a number, returns the argument from that index. For example
         *
         *      var s = CLI.util.Format.pick(2, &#39;zero&#39;, &#39;one&#39;, &#39;two&#39;);
         *      // s === &#39;two&#39;
         *
         * Otherwise, `value` is treated in a truthy/falsey manner like so:
         *
         *      var s = CLI.util.Format.pick(null, &#39;first&#39;, &#39;second&#39;);
         *      // s === &#39;first&#39;
         *
         *      s = CLI.util.Format.pick({}, &#39;first&#39;, &#39;second&#39;);
         *      // s === &#39;second&#39;
         *
         * The usefulness of this formatter method is in templates. For example:
         *
         *      {foo:pick(&quot;F&quot;,&quot;T&quot;)}
         *
         *      {bar:pick(&quot;first&quot;,&quot;second&quot;,&quot;third&quot;)}
         *
         * @param {Boolean} value The &quot;if&quot; value.
         * @param {Mixed} firstValue
         * @param {Mixed} secondValue
         */
        pick: function (value, firstValue, secondValue) {

            if (CLI.isNumber(value)) {

                var ret = arguments[value + 1];

                if (ret) {
                    return ret;
                }

            }

            return value ? secondValue : firstValue;
        },

        // }}}
        // {{{ stripTags

<span id='CLI-util-Format-method-stripTags'>        /**
</span>         * Strips all HTML tags.
         * @param {Object} value The text from which to strip tags
         * @return {String} The stripped text
         */
        stripTags : function(v) {
            return !v ? v : String(v).replace(me.stripTagsRe, &quot;&quot;);
        },

        // }}}
        // {{{ stripScripts

<span id='CLI-util-Format-method-stripScripts'>        /**
</span>         * Strips all script tags.
         * @param {Object} value The text from which to strip script tags
         * @return {String} The stripped text
         */
        stripScripts : function(v) {
            return !v ? v : String(v).replace(me.stripScriptsRe, &quot;&quot;);
        },

        // }}}
        // {{{ fileSize

<span id='CLI-util-Format-method-fileSize'>        /**
</span>         * Simple format for a file size (xxx bytes, xxx KB, xxx MB).
         * @param {Number/String} size The numeric value to format
         * @return {String} The formatted file size
         */
        fileSize : (function() {

            var byteLimit = 1024,
                kbLimit = 1048576,
                mbLimit = 1073741824;

            return function(size) {

                var out;

                if (size &lt; byteLimit) {

                    if (size === 1) {

                        out = &#39;1 byte&#39;;

                    } else {

                        out = size + &#39; bytes&#39;;

                    }

                } else if (size &lt; kbLimit) {

                    out = (Math.round(((size*10) / byteLimit))/10) + &#39; KB&#39;;

                } else if (size &lt; mbLimit) {

                    out = (Math.round(((size*10) / kbLimit))/10) + &#39; MB&#39;;

                } else {

                    out = (Math.round(((size*10) / mbLimit))/10) + &#39; GB&#39;;

                }

                return out;

            };

        })(),

        // }}}
        // {{{ math

<span id='CLI-util-Format-method-math'>        /**
</span>         * It does simple math for use in a template, for example:
         *
         *     var tpl = new CLI.Template(&#39;{value} * 10 = {value:math(&quot;* 10&quot;)}&#39;);
         *
         * @return {Function} A function that operates on the passed value.
         * @method
         */
        math : (function() {

            var fns = {};

            return function(v, a) {

                if (!fns[a]) {

                    fns[a] = CLI.functionFactory(&#39;v&#39;, &#39;return v &#39; + a + &#39;;&#39;);

                }

                return fns[a](v);
            };

        }()),

        // }}}
        // {{{ round

<span id='CLI-util-Format-method-round'>        /**
</span>         * Rounds the passed number to the required decimal precision.
         * @param {Number/String} value The numeric value to round.
         * @param {Number} [precision] The number of decimal places to which to round the
         * first parameter&#39;s value. If `undefined` the `value` is passed to `Math.round`
         * otherwise the value is returned unmodified.
         * @return {Number} The rounded value.
         */
        round : function(value, precision) {

            var result = Number(value);

            if (typeof precision === &#39;number&#39;) {

                precision = Math.pow(10, precision);
                result = Math.round(value * precision) / precision;

            } else if (precision === undefined) {

                result = Math.round(result);

            }

            return result;
        },

        // }}}
        // {{{ number

<span id='CLI-util-Format-method-number'>        /**
</span>         * Formats the passed number according to the passed format string.
         *
         * The number of digits after the decimal separator character specifies the number of
         * decimal places in the resulting string. The *local-specific* decimal character is
         * used in the result.
         *
         * The *presence* of a thousand separator character in the format string specifies that
         * the *locale-specific* thousand separator (if any) is inserted separating thousand groups.
         *
         * By default, &quot;,&quot; is expected as the thousand separator, and &quot;.&quot; is expected as the decimal separator.
         *
         * Locale-specific characters are always used in the formatted output when inserting
         * thousand and decimal separators. These can be set using the {@link #thousandSeparator} and
         * {@link #decimalSeparator} options.
         *
         * The format string must specify separator characters according to US/UK conventions (&quot;,&quot; as the
         * thousand separator, and &quot;.&quot; as the decimal separator)
         *
         * To allow specification of format strings according to local conventions for separator characters, add
         * the string `/i` to the end of the format string. This format depends on the {@link #thousandSeparator} and
         * {@link #decimalSeparator} options. For example, if using European style separators, then the format string
         * can be specified as `&#39;0.000,00&#39;`. This would be equivalent to using `&#39;0,000.00&#39;` when using US style formatting.
         *
         * Examples (123456.789):
         *
         * - `0` - (123457) show only digits, no precision
         * - `0.00` - (123456.79) show only digits, 2 precision
         * - `0.0000` - (123456.7890) show only digits, 4 precision
         * - `0,000` - (123,457) show comma and digits, no precision
         * - `0,000.00` - (123,456.79) show comma and digits, 2 precision
         * - `0,0.00` - (123,456.79) shortcut method, show comma and digits, 2 precision
         * - `0.####` - (123,456.789) Allow maximum 4 decimal places, but do not right pad with zeroes
         * - `0.00##` - (123456.789) Show at least 2 decimal places, maximum 4, but do not right pad with zeroes
         *
         * @param {Number} v The number to format.
         * @param {String} formatString The way you would like to format this text.
         * @return {String} The formatted number.
         */
        number : function(v, formatString) {

            if (!formatString) {
                return v;
            }

            if (isNaN(v)) {
                return &#39;&#39;;
            }

            var formatFn = me.formatFns[formatString];

            // Generate formatting function to be cached and reused keyed by the format string.
            // This results in a 100% performance increase over analyzing the format string each invocation.
            if (!formatFn) {

                var originalFormatString = formatString,
                    comma = me.thousandSeparator,
                    decimalSeparator = me.decimalSeparator,
                    precision = 0,
                    trimPart = &#39;&#39;,
                    hasComma,
                    splitFormat,
                    extraChars,
                    trimTrailingZeroes,
                    code, len;

                // The &quot;/i&quot; suffix allows caller to use a locale-specific formatting string.
                // Clean the format string by removing all but numerals and the decimal separator.
                // Then split the format string into pre and post decimal segments according to *what* the
                // decimal separator is. If they are specifying &quot;/i&quot;, they are using the local convention in the format string.
                if (formatString.substr(formatString.length - 2) === &#39;/i&#39;) {

                    // In a vast majority of cases, the separator will never change over the lifetime of the application.
                    // So we&#39;ll only regenerate this if we really need to
                    if (!me.I18NFormatCleanRe || me.lastDecimalSeparator !== decimalSeparator) {
                        me.I18NFormatCleanRe = new RegExp(&#39;[^\\d\\&#39; + decimalSeparator + &#39;]&#39;,&#39;g&#39;);
                        me.lastDecimalSeparator = decimalSeparator;
                    }

                    formatString = formatString.substr(0, formatString.length - 2);
                    hasComma = formatString.indexOf(comma) !== -1;
                    splitFormat = formatString.replace(me.I18NFormatCleanRe, &#39;&#39;).split(decimalSeparator);

                } else {

                    hasComma = formatString.indexOf(&#39;,&#39;) !== -1;
                    splitFormat = formatString.replace(me.formatCleanRe, &#39;&#39;).split(&#39;.&#39;);

                }

                extraChars = formatString.replace(me.formatPattern, &#39;&#39;);

                if (splitFormat.length &gt; 2) {

                    CLI.Error.raise({
                        sourceClass: &quot;CLI.util.Format&quot;,
                        sourceMethod: &quot;number&quot;,
                        value: v,
                        formatString: formatString,
                        msg: &quot;Invalid number format, should have no more than 1 decimal&quot;
                    });

                } else if (splitFormat.length === 2) {

                    precision = splitFormat[1].length;

                    // Formatting ending in .##### means maximum 5 trailing significant digits
                    trimTrailingZeroes = splitFormat[1].match(me.hashRe);

                    if (trimTrailingZeroes) {

                        len = trimTrailingZeroes[0].length;
                        // Need to escape, since this will be &#39;.&#39; by default
                        trimPart = &#39;trailingZeroes=new RegExp(CLI.String.escapeRegex(utilFormat.decimalSeparator) + &quot;*0{0,&#39; + len + &#39;}$&quot;)&#39;;

                    }

                }

                // The function we create is called immediately and returns a closure which has access to vars and some fixed values; RegExes and the format string.
                code = [
                    &#39;var utilFormat=CLI.util.Format,extNumber=CLI.Number,neg,absVal,fnum,parts&#39; +
                        (hasComma ? &#39;,thousandSeparator,thousands=[],j,n,i&#39; : &#39;&#39;) +
                        (extraChars  ? &#39;,formatString=&quot;&#39; + formatString + &#39;&quot;,formatPattern=/[\\d,\\.#]+/&#39; : &#39;&#39;) +
                        &#39;,trailingZeroes;&#39; +
                    &#39;return function(v) {&#39; +
                    &#39;if(typeof v!==&quot;number&quot;&amp;&amp;isNaN(v=extNumber.from(v,NaN)))return&quot;&quot;;&#39; +
                    &#39;neg=v&lt;0;&#39;,
                    &#39;absVal=Math.abs(v);&#39;,
                    &#39;fnum=CLI.Number.toFixed(absVal, &#39; + precision + &#39;);&#39;,
                    trimPart, &#39;;&#39;
                ];

                if (hasComma) {

                    // If we have to insert commas...

                    // split the string up into whole and decimal parts if there are decimals
                    if (precision) {
                        code[code.length] = &#39;parts=fnum.split(&quot;.&quot;);&#39;;
                        code[code.length] = &#39;fnum=parts[0];&#39;;
                    }

                    code[code.length] =
                        &#39;if(absVal&gt;=1000) {&#39;;
                            code[code.length] = &#39;thousandSeparator=utilFormat.thousandSeparator;&#39; +
                            &#39;thousands.length=0;&#39; +
                            &#39;j=fnum.length;&#39; +
                            &#39;n=fnum.length%3||3;&#39; +
                            &#39;for(i=0;i&lt;j;i+=n) {&#39; +
                                &#39;if(i!==0) {&#39; +
                                    &#39;n=3;&#39; +
                                &#39;}&#39; +
                                &#39;thousands[thousands.length]=fnum.substr(i,n);&#39; +
                            &#39;}&#39; +
                            &#39;fnum=thousands.join(thousandSeparator);&#39; +
                        &#39;}&#39;;

                    if (precision) {

                        code[code.length] = &#39;fnum += utilFormat.decimalSeparator+parts[1];&#39;;

                    }

                } else if (precision) {

                    // If they are using a weird decimal separator, split and concat using it
                    code[code.length] = &#39;if(utilFormat.decimalSeparator!==&quot;.&quot;) {&#39; +
                        &#39;parts=fnum.split(&quot;.&quot;);&#39; +
                        &#39;fnum=parts[0]+utilFormat.decimalSeparator+parts[1];&#39; +
                    &#39;}&#39;;

                }

                if (trimTrailingZeroes) {

                    code[code.length] = &#39;fnum=fnum.replace(trailingZeroes,&quot;&quot;);&#39;;

                }

                /*
                 * Edge case. If we have a very small negative number it will get rounded to 0,
                 * however the initial check at the top will still report as negative. Replace
                 * everything but 1-9 and check if the string is empty to determine a 0 value.
                 */
                code[code.length] = &#39;if(neg&amp;&amp;fnum!==&quot;&#39; + (precision ? &#39;0.&#39; + CLI.String.repeat(&#39;0&#39;, precision) : &#39;0&#39;) + &#39;&quot;)fnum=&quot;-&quot;+fnum;&#39;;

                code[code.length] = &#39;return &#39;;

                // If there were extra characters around the formatting string, replace the format string part with the formatted number.
                if (extraChars) {

                    code[code.length] = &#39;formatString.replace(formatPattern, fnum);&#39;;

                } else {

                    code[code.length] = &#39;fnum;&#39;;

                }

                code[code.length] = &#39;};&#39;;

                formatFn = me.formatFns[originalFormatString] = CLI.functionFactory(&#39;CLI&#39;, code.join(&#39;&#39;))(CLI);
            }

            return formatFn(v);

        },

        // }}}
        // {{{ numberRenderer

<span id='CLI-util-Format-method-numberRenderer'>        /**
</span>         * Returns a number rendering function that can be reused to apply a number format multiple
         * times efficiently.
         *
         * @param {String} format Any valid number format string for {@link #number}
         * @return {Function} The number formatting function
         */
        numberRenderer : function(format) {

            return function(v) {

                return me.number(v, format);

            };

        },

        // }}}
        // {{{ percent

<span id='CLI-util-Format-method-percent'>        /**
</span>         * Formats the passed number as a percentage according to the passed format string.
         * The number should be between 0 and 1 to represent 0% to 100%.
         *
         * @param {Number} value The percentage to format.
         * @param {String} [formatString=&quot;0&quot;] See {@link #number} for details.
         * @return {String} The formatted percentage.
         */
        percent: function (value, formatString) {

            return me.number(value * 100, formatString || &#39;0&#39;) + me.percentSign;

        },

        // }}}
        // {{{ attributes

<span id='CLI-util-Format-method-attributes'>        /**
</span>         * Formats an object of name value properties as HTML element attribute values suitable for using when creating textual markup.
         * @param {Object} attributes An object containing the HTML attributes as properties eg: `{height:40, vAlign:&#39;top&#39;}`
         */
        attributes: function(attributes) {

            if (typeof attributes === &#39;object&#39;) {

                var result = [],
                    name;

                for (name in attributes) {

                    if (attributes.hasOwnProperty(name)) {

                        result.push(name, &#39;=&quot;&#39;, name === &#39;style&#39; ?
                                CLI.DomHelper.generateStyles(attributes[name], null, true) :
                                CLI.htmlEncode(attributes[name]), &#39;&quot; &#39;);

                    }

                }

                attributes = result.join(&#39;&#39;);

            }

            return attributes || &#39;&#39;;

        },

        // }}}
        // {{{ plural

<span id='CLI-util-Format-method-plural'>        /**
</span>         * Selectively do a plural form of a word based on a numeric value. For example, in a template,
         * `{commentCount:plural(&quot;Comment&quot;)}`  would result in `&quot;1 Comment&quot;` if commentCount was 1 or
         * would be `&quot;x Comments&quot;` if the value is 0 or greater than 1.
         *
         * @param {Number} value The value to compare against
         * @param {String} singular The singular form of the word
         * @param {String} [plural] The plural form of the word (defaults to the singular with an &quot;s&quot;)
         */
        plural : function(v, s, p) {
            return v +&#39; &#39; + (v === 1 ? s : (p ? p : s+&#39;s&#39;));
        },

        // }}}
        // {{{ nl2br

<span id='CLI-util-Format-method-nl2br'>        /**
</span>         * Converts newline characters to the HTML tag `&lt;br/&gt;`
         *
         * @param {String} v The string value to format.
         * @return {String} The string with embedded `&lt;br/&gt;` tags in place of newlines.
         */
        nl2br : function(v) {
            return CLI.isEmpty(v) ? &#39;&#39; : v.replace(me.nl2brRe, &#39;&lt;br/&gt;&#39;);
        },

        // }}}
        // {{{ capitalize

<span id='CLI-util-Format-method-capitalize'>        /**
</span>         * Alias for {@link CLI.String#capitalize}.
         * @method
         * @inheritdoc CLI.String#capitalize
         */
        capitalize: CLI.String.capitalize,

        // }}}
        // {{{ uncapitalize

<span id='CLI-util-Format-method-uncapitalize'>        /**
</span>         * Alias for {@link CLI.String#uncapitalize}.
         * @method
         * @inheritdoc CLI.String#uncapitalize
         */
        uncapitalize: CLI.String.uncapitalize,

        // }}}
        // {{{ ellipsis

<span id='CLI-util-Format-method-ellipsis'>        /**
</span>         * Alias for {@link CLI.String#ellipsis}.
         * @method
         * @inheritdoc CLI.String#ellipsis
         */
        ellipsis: CLI.String.ellipsis,

        // }}}
        // {{{ escape

<span id='CLI-util-Format-method-escape'>        /**
</span>         * Alias for {@link CLI.String#escape}.
         * @method
         * @inheritdoc CLI.String#escape
         */
        escape: CLI.String.escape,

        // }}}
        // {{{ escapeRegex

<span id='CLI-util-Format-method-escapeRegex'>        /**
</span>         * Alias for {@link CLI.String#escapeRegex}.
         * @method
         * @inheritdoc CLI.String#escapeRegex
         */
        escapeRegex : CLI.String.escapeRegex,

        // }}}
        // {{{ htmlDecode

<span id='CLI-util-Format-method-htmlDecode'>        /**
</span>         * Alias for {@link CLI.String#htmlDecode}.
         * @method
         * @inheritdoc CLI.String#htmlDecode
         */
        htmlDecode: CLI.String.htmlDecode,

        // }}}
        // {{{ htmlEncode

<span id='CLI-util-Format-method-htmlEncode'>        /**
</span>         * Alias for {@link CLI.String#htmlEncode}.
         * @method
         * @inheritdoc CLI.String#htmlEncode
         */
        htmlEncode: CLI.String.htmlEncode,

        // }}}
        // {{{ leftPad

<span id='CLI-util-Format-method-leftPad'>        /**
</span>         * Alias for {@link CLI.String#leftPad}.
         * @method
         * @inheritdoc CLI.String#leftPad
         */
        leftPad: CLI.String.leftPad,

        // }}}
        // {{{ toggle

<span id='CLI-util-Format-method-toggle'>        /**
</span>         * Alias for {@link CLI.String#toggle}.
         * @method
         * @inheritdoc CLI.String#toggle
         */
        toggle: CLI.String.toggle,

        // }}}
        // {{{ trim

<span id='CLI-util-Format-method-trim'>        /**
</span>         * Alias for {@link CLI.String#trim}.
         * @method
         * @inheritdoc CLI.String#trim
         */
        trim : CLI.String.trim,

        // }}}
        // {{{ parseBox

<span id='CLI-util-Format-method-parseBox'>        /**
</span>         * Parses a number or string representing margin sizes into an object.
         * Supports CSS-style margin declarations (e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and
         * &quot;10 10 10 10&quot; are all valid options and would return the same result).
         *
         * @param {Number/String} box The encoded margins
         * @return {Object} An object with margin sizes for top, right, bottom and left
         */
        parseBox : function(box) {

            box = box || 0;

            if (typeof box === &#39;number&#39;) {

                return {
                    top   : box,
                    right : box,
                    bottom: box,
                    left  : box
                };

            }

            var parts  = box.split(&#39; &#39;),
            ln = parts.length;

            if (ln === 1) {
                parts[1] = parts[2] = parts[3] = parts[0];
            }
            else if (ln === 2) {
                parts[2] = parts[0];
                parts[3] = parts[1];
            }
            else if (ln === 3) {
                parts[3] = parts[1];
            }

            return {
                top   :parseInt(parts[0], 10) || 0,
                right :parseInt(parts[1], 10) || 0,
                bottom:parseInt(parts[2], 10) || 0,
                left  :parseInt(parts[3], 10) || 0
            };
        }

        // }}}

    };

});

// }}}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
