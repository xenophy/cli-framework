<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
/* jshint eqnull:true */

<span id='global-property-'>/**
</span> * This file is part of CLI Framework
 * @ignore
 */

(function() {

    &quot;use strict&quot;;

    var objectPrototype = Object.prototype,
        toString        = objectPrototype.toString,
        iterableRe      = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/,
        MSDateRe        = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/,
        callOverrideParent = function () {

            var method = callOverrideParent.caller.caller;

            return method.$owner.prototype[method.$name].apply(this, arguments);
        };

    CLI.apply(CLI, {

        // {{{ applyIf

<span id='CLI-method-applyIf'>        /**
</span>         * @method applyIf
         * @member CLI
         * Copies all the properties of config to object if they don&#39;t already exist.
         * @param {Object} object The receiver of the properties
         * @param {Object} config The source of the properties
         * @return {Object} returns obj
         */
        applyIf: function(object, config) {

            var property;

            if (object) {
                for (property in config) {
                    if (object[property] === undefined) {
                        object[property] = config[property];
                    }
                }
            }

            return object;
        },

        // }}}
        // {{{ iterate

<span id='CLI-method-iterate'>        /**
</span>         * @method iterate
         * @member CLI
         * Iterates either an array or an object. This method delegates to
         * {@link CLI.Array#each CLI.Array.each} if the given value is iterable, and {@link CLI.Object#each CLI.Object.each} otherwise.
         *
         * @param {Object/Array} object The object or array to be iterated.
         * @param {Function} fn The function to be called for each iteration. See and {@link CLI.Array#each CLI.Array.each} and
         * {@link CLI.Object#each CLI.Object.each} for detailed lists of arguments passed to this function depending on the given object
         * type that is being iterated.
         * @param {Object} [scope] The scope (`this` reference) in which the specified function is executed.
         * Defaults to the object being iterated itself.
         */
        iterate: function(object, fn, scope) {

            if (CLI.isEmpty(object)) {
                return;
            }

            if (scope === undefined) {
                scope = object;
            }

            if (CLI.isIterable(object)) {
                CLI.Array.each.call(CLI.Array, object, fn, scope);
            }
            else {
                CLI.Object.each.call(CLI.Object, object, fn, scope);
            }

        },

        // }}}
        // {{{ isArray

<span id='CLI-method-isArray'>        /**
</span>         * @method isArray
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Array, `false` otherwise.
         *
         * @param {Object} target The target to test.
         * @return {Boolean}
         * @method
         */
        isArray: Array.isArray,

        // }}}
        // {{{ isDate

<span id='CLI-method-isDate'>        /**
</span>         * @method isDate
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Date object, `false` otherwise.
         * @param {Object} object The object to test.
         * @return {Boolean}
         */
        isDate: function(value) {
            return toString.call(value) === &#39;[object Date]&#39;;
        },

        // }}}
        // {{{ isEmpty

<span id='CLI-method-isEmpty'>        /**
</span>         * @method isEmpty
         * @member CLI
         * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:
         *
         * - `null`
         * - `undefined`
         * - a zero-length array
         * - a zero-length string (Unless the `allowEmptyString` parameter is set to `true`)
         *
         * @param {Object} value The value to test.
         * @param {Boolean} [allowEmptyString=false] `true` to allow empty strings.
         * @return {Boolean}
         */
        isEmpty: function(value, allowEmptyString) {
            return (value == null) || (!allowEmptyString ? value === &#39;&#39; : false) || (CLI.isArray(value) &amp;&amp; value.length === 0);
        },

        // }}}
        // {{{ isMSDate

<span id='CLI-method-isMSDate'>        /**
</span>         * @method isMSDate
         * @member CLI
         * Returns &#39;true&#39; if the passed value is a String that matches the MS Date JSON
         * encoding format.
         * @param {String} value The string to test.
         * @return {Boolean}
         */
        isMSDate: function(value) {

            if (!CLI.isString(value)) {
                return false;
            }

            return MSDateRe.test(value);
        },

        // }}}
        // {{{ isObject

<span id='CLI-method-isObject'>        /**
</span>         * @method isObject
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Object, `false` otherwise.
         * @param {Object} value The value to test.
         * @return {Boolean}
         * @method
         */
        isObject: function(value) {
            return toString.call(value) === &#39;[object Object]&#39;;
        },

        // }}}
        // {{{ isPrimitive

<span id='CLI-method-isPrimitive'>        /**
</span>         * @method isPrimitive
         * @member CLI
         * Returns `true` if the passed value is a JavaScript &#39;primitive&#39;, a string, number
         * or boolean.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isPrimitive: function(value) {

            var type = typeof value;

            return type === &#39;string&#39; || type === &#39;number&#39; || type === &#39;boolean&#39;;
        },

        // }}}
        // {{{ isFunction

<span id='CLI-method-isFunction'>        /**
</span>         * @method isFunction
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Function, `false` otherwise.
         * @param {Object} value The value to test.
         * @return {Boolean}
         * @method
         */
        isFunction: function(value) {
            return !!value &amp;&amp; typeof value === &#39;function&#39;;
        },

        // }}}
        // {{{ isNumber

<span id='CLI-method-isNumber'>        /**
</span>         * @method isNumber
         * @member CLI
         * Returns `true` if the passed value is a number. Returns `false` for non-finite numbers.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isNumber: function(value) {
            return typeof value === &#39;number&#39; &amp;&amp; isFinite(value);
        },

        // }}}
        // {{{ isNumeric

<span id='CLI-method-isNumeric'>        /**
</span>         * @method isNumeric
         * @member CLI
         * Validates that a value is numeric.
         * @param {Object} value Examples: 1, &#39;1&#39;, &#39;2.34&#39;
         * @return {Boolean} True if numeric, false otherwise
         */
        isNumeric: function(value) {
            return !isNaN(parseFloat(value)) &amp;&amp; isFinite(value);
        },

        // }}}
        // {{{ isString

<span id='CLI-method-isString'>        /**
</span>         * @method isString
         * @member CLI
         * Returns `true `if the passed value is a string.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isString: function(value) {
            return typeof value === &#39;string&#39;;
        },

        // }}}
        // {{{ isBoolean

<span id='CLI-method-isBoolean'>        /**
</span>         * @method isBoolean
         * @member CLI
         * Returns `true` if the passed value is a boolean.
         *
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isBoolean: function(value) {
            return typeof value === &#39;boolean&#39;;
        },

        // }}}
        // {{{ isDefined

<span id='CLI-method-isDefined'>        /**
</span>         * @method isDefined
         * @member CLI
         * Returns `true` if the passed value is defined.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isDefined: function(value) {
            return typeof value !== &#39;undefined&#39;;
        },

        // }}}
        // {{{ isIterable

<span id='CLI-method-isIterable'>        /**
</span>         * @method isIterable
         * @member CLI
         * Returns `true` if the passed value is iterable, that is, if elements of it are addressable using array
         * notation with numeric indices, `false` otherwise.
         *
         * Arrays and function `arguments` objects are iterable. Also HTML collections such as `NodeList` and `HTMLCollection&#39;
         * are iterable.
         *
         * @param {Object} value The value to test
         * @return {Boolean}
         */
        isIterable: function(value) {

            if (!value || typeof value.length !== &#39;number&#39; || typeof value === &#39;string&#39; || CLI.isFunction(value)) {
                return false;
            }

            if (value.hasOwnProperty(&#39;length&#39;) &amp;&amp; !value.propertyIsEnumerable(&#39;length&#39;)) {
                return true;
            }

            return iterableRe.test(toString.call(value));
        },

        // }}}
        // {{{ now

<span id='CLI-method-now'>        /**
</span>         * @method now
         * @member CLI
         * Returns the current timestamp.
         * @return {Number} Milliseconds since UNIX epoch.
         * @method
         */
        now: Date.now,

        // }}}
        // {{{ functionFactory

<span id='global-method-functionFactory'>        /**
</span>         * @private
         */
        functionFactory: function() {

            var args = Array.prototype.slice.call(arguments),
                ln;

            return Function.prototype.constructor.apply(Function.prototype, args);
        },

        // }}}
        // {{{ valueFrom

<span id='CLI-method-valueFrom'>        /**
</span>         * @method valueFrom
         * @member CLI
         * Returns the given value itself if it&#39;s not empty, as described in {@link CLI#isEmpty}; returns the default
         * value (second argument) otherwise.
         *
         * @param {Object} value The value to test.
         * @param {Object} defaultValue The value to return if the original value is empty.
         * @param {Boolean} [allowBlank=false] `true` to allow zero length strings to qualify as non-empty.
         * @return {Object} value, if non-empty, else defaultValue.
         */
        valueFrom: function(value, defaultValue, allowBlank){
            return CLI.isEmpty(value, allowBlank) ? defaultValue : value;
        },

        // }}}
        // {{{ override

<span id='CLI-method-override'>        /**
</span>         * Overrides members of the specified `target` with the given values.
         *
         * If the `target` is a class declared using {@link CLI#define CLI.define}, the
         * `override` method of that class is called (see {@link CLI.Base#override}) given
         * the `overrides`.
         *
         * If the `target` is a function, it is assumed to be a constructor and the contents
         * of `overrides` are applied to its `prototype` using {@link CLI#apply CLI.apply}.
         *
         * If the `target` is an instance of a class declared using {@link CLI#define CLI.define},
         * the `overrides` are applied to only that instance. In this case, methods are
         * specially processed to allow them to use {@link CLI.Base#callParent}.
         *
         *      var panel = new CLI.Panel({ ... });
         *
         *      CLI.override(panel, {
         *          initComponent: function () {
         *              // extra processing...
         *
         *              this.callParent();
         *          }
         *      });
         *
         * If the `target` is none of these, the `overrides` are applied to the `target`
         * using {@link CLI#apply CLI.apply}.
         *
         * Please refer to {@link CLI#define CLI.define} and {@link CLI.Base#override} for
         * further details.
         *
         * @param {Object} target The target to override.
         * @param {Object} overrides The properties to add or replace on `target`.
         * @method override
         * @member CLI
         */
        override: function (target, overrides) {

            if (target.$isClass) {

                target.override(overrides);

            } else if (typeof target == &#39;function&#39;) {

                CLI.apply(target.prototype, overrides);

            } else {

                var owner = target.self,
                    name, value;

                if (owner &amp;&amp; owner.$isClass) { // if (instance of CLI.define&#39;d class)

                    for (name in overrides) {

                        if (overrides.hasOwnProperty(name)) {

                            value = overrides[name];

                            if (typeof value === &#39;function&#39;) {

                                if (owner.$className) {
                                    value.displayName = owner.$className + &#39;#&#39; + name;
                                }

                                value.$name = name;
                                value.$owner = owner;
                                value.$previous = target.hasOwnProperty(name)
                                    ? target[name] // already hooked, so call previous hook
                                    : callOverrideParent; // calls by name on prototype
                            }

                            target[name] = value;
                        }
                    }

                } else {

                    CLI.apply(target, overrides);

                }

            }

            return target;
        },

        // }}}
        // {{{ clone

<span id='CLI-method-clone'>        /**
</span>         * @method clone
         * @member CLI
         * Clone simple variables including array, {}-like objects, DOM nodes and Date without keeping the old reference.
         * A reference for the object itself is returned if it&#39;s not a direct decendant of Object. For model cloning,
         * see {@link CLI.data.Model#copy Model.copy}.
         *
         * @param {Object} item The variable to clone
         * @return {Object} clone
         */
        clone: function(item) {

            if (item === null || item === undefined) {
                return item;
            }

            var type = toString.call(item),
                i, j, k, clone, key;

            // Date
            if (type === &#39;[object Date]&#39;) {
                return new Date(item.getTime());
            }

            // Array
            if (type === &#39;[object Array]&#39;) {
                i = item.length;

                clone = [];

                while (i--) {
                    clone[i] = CLI.clone(item[i]);
                }
            }

            // Object
            else if (type === &#39;[object Object]&#39; &amp;&amp; item.constructor === Object) {

                clone = {};

                for (key in item) {
                    clone[key] = CLI.clone(item[key]);
                }

            }

            return clone || item;
        },

        // }}}
        // {{{ typeOf

<span id='CLI-method-typeOf'>        /**
</span>         * @method typeOf
         * @member CLI
         * Returns the type of the given variable in string format. List of possible values are:
         *
         * - `undefined`: If the given value is `undefined`
         * - `null`: If the given value is `null`
         * - `string`: If the given value is a string
         * - `number`: If the given value is a number
         * - `boolean`: If the given value is a boolean value
         * - `date`: If the given value is a `Date` object
         * - `function`: If the given value is a function reference
         * - `object`: If the given value is an object
         * - `array`: If the given value is an array
         * - `regexp`: If the given value is a regular expression
         *
         * @param {Object} value
         * @return {String}
         */
        typeOf: (function () {

            var nonWhitespaceRe = /\S/,
                toString = Object.prototype.toString,
                typeofTypes = {
                    number: 1,
                    string: 1,
                    &#39;boolean&#39;: 1,
                    &#39;undefined&#39;: 1
                },
                toStringTypes = {
                    &#39;[object Array]&#39;  : &#39;array&#39;,
                    &#39;[object Date]&#39;   : &#39;date&#39;,
                    &#39;[object Boolean]&#39;: &#39;boolean&#39;,
                    &#39;[object Number]&#39; : &#39;number&#39;,
                    &#39;[object RegExp]&#39; : &#39;regexp&#39;
                };

            return function(value) {

                if (value === null) {
                    return &#39;null&#39;;
                }

                var type = typeof value,
                    ret, typeToString;

                if (typeofTypes[type]) {
                    return type;
                }

                ret = toStringTypes[typeToString = toString.call(value)];

                if (ret) {
                    return ret;
                }

                if (type === &#39;function&#39;) {
                    return &#39;function&#39;;
                }

                if (type === &#39;object&#39;) {
                    return &#39;object&#39;;
                }

                // TODO: implemented after, enable
                /*
                CLI.Error.raise({
                    sourceClass: &#39;Ext&#39;,
                    sourceMethod: &#39;typeOf&#39;,
                    msg: &#39;Failed to determine the type of &quot;&#39; + value + &#39;&quot;.&#39;
                });
               */

                return typeToString;
            };

        }()),

        // }}}

    });

})();

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
