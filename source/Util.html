<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
/* jshint eqnull:true */

/*!
 * This file is part of CLI Framework
 */

(function() {

    &quot;use strict&quot;;

    var objectPrototype = Object.prototype,
        toString        = objectPrototype.toString,
        iterableRe      = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/,
        MSDateRe        = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/,
        callOverrideParent = function () {

            var method = callOverrideParent.caller.caller;

            return method.$owner.prototype[method.$name].apply(this, arguments);
        };

    CLI.apply(CLI, {

        // shortcut for the special named scopes for listener scope resolution
        _namedScopes: {
            &#39;this&#39;: { isThis: 1 },
            controller: { isController: 1 },
            // these two are private, used to indicate that listeners were declared on the
            // class body with either an unspecified scope, or scope:&#39;controller&#39;
            self: { isSelf: 1 },
            &#39;self.controller&#39;: { isSelf: 1, isController: 1 }
        },

        // {{{ callback

<span id='CLI-method-callback'>        /**
</span>         * @method callback
         * @member CLI
         * Execute a callback function in a particular scope. If `callback` argument is a
         * function reference, that is called. If it is a string, the string is assumed to
         * be the name of a method on the given `scope`. If no function is passed the call
         * is ignored.
         *
         * For example, these calls are equivalent:
         *
         *      var myFunc = this.myFunc;
         *
         *      CLI.callback(&#39;myFunc&#39;, this, [arg1, arg2]);
         *      CLI.callback(myFunc, this, [arg1, arg2]);
         *
         *      CLI.isFunction(myFunc) &amp;&amp; this.myFunc(arg1, arg2);
         *
         * @param {Function/String} callback The callback function to execute or the name of
         * the callback method on the provided `scope`.
         * @param {Object} [scope] The scope in which `callback` should be invoked. If `callback`
         * is a string this object provides the method by that name. If this is `null` then
         * the `caller` is used to resolve the scope to a `ViewController` or the proper
         * `defaultListenerScope`.
         * @param {Array} [args] The arguments to pass to the function.
         * @param {Number} [delay] Pass a number to delay the call by a number of milliseconds.
         * @param {Object} [caller] The object calling the callback. This is used to resolve
         * named methods when no explicit `scope` is provided.
         * @param {Object} [defaultScope=caller] The default scope to return if none is found.
         * @return The value returned by the callback or `undefined` (if there is a `delay`
         * or if the `callback` is not a function).
         */
        callback: function (callback, scope, args, delay, caller, defaultScope) {

            if (!callback) {
                return;
            }

            var namedScope = (scope in CLI._namedScopes);

            if (callback.charAt) { // if (isString(fn))

                if ((!scope || namedScope) &amp;&amp; caller) {
                    scope = caller.resolveListenerScope(namedScope ? scope : defaultScope);
                }
                //&lt;debug&gt;
                if (!scope || !CLI.isObject(scope)) {
                    CLI.Error.raise(&#39;Named method &quot;&#39; + callback + &#39;&quot; requires a scope object&#39;);
                }
                if (!CLI.isFunction(scope[callback])) {
                    CLI.Error.raise(&#39;No method named &quot;&#39; + callback + &#39;&quot; on &#39; +
                                    (scope.$className || &#39;scope object&#39;));
                }
                //&lt;/debug&gt;

                callback = scope[callback];

            } else if (namedScope) {

                scope = defaultScope || caller;

            } else if (!scope) {

                scope = caller;

            }

            var ret;

            if (callback &amp;&amp; CLI.isFunction(callback)) {

                scope = scope || CLI.global;

                if (delay) {

                    CLI.defer(callback, delay, scope, args);

                } else if (args) {

                    ret = callback.apply(scope, args);

                } else {

                    ret = callback.call(scope);

                }

            }

            return ret;
        },

        // }}}
        // {{{ applyIf

<span id='CLI-method-applyIf'>        /**
</span>         * @method applyIf
         * @member CLI
         * Copies all the properties of config to object if they don&#39;t already exist.
         * @param {Object} object The receiver of the properties
         * @param {Object} config The source of the properties
         * @return {Object} returns obj
         */
        applyIf: function(object, config) {

            var property;

            if (object) {
                for (property in config) {
                    if (object[property] === undefined) {
                        object[property] = config[property];
                    }
                }
            }

            return object;
        },

        // }}}
        // {{{ iterate

<span id='CLI-method-iterate'>        /**
</span>         * @method iterate
         * @member CLI
         * Iterates either an array or an object. This method delegates to
         * {@link CLI.Array#each CLI.Array.each} if the given value is iterable, and {@link CLI.Object#each CLI.Object.each} otherwise.
         *
         * @param {Object/Array} object The object or array to be iterated.
         * @param {Function} fn The function to be called for each iteration. See and {@link CLI.Array#each CLI.Array.each} and
         * {@link CLI.Object#each CLI.Object.each} for detailed lists of arguments passed to this function depending on the given object
         * type that is being iterated.
         * @param {Object} [scope] The scope (`this` reference) in which the specified function is executed.
         * Defaults to the object being iterated itself.
         */
        iterate: function(object, fn, scope) {

            if (CLI.isEmpty(object)) {
                return;
            }

            if (scope === undefined) {
                scope = object;
            }

            if (CLI.isIterable(object)) {
                CLI.Array.each.call(CLI.Array, object, fn, scope);
            }
            else {
                CLI.Object.each.call(CLI.Object, object, fn, scope);
            }

        },

        // }}}
        // {{{ isArray

<span id='CLI-method-isArray'>        /**
</span>         * @method isArray
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Array, `false` otherwise.
         *
         * @param {Object} target The target to test.
         * @return {Boolean}
         * @method
         */
        isArray: Array.isArray,

        // }}}
        // {{{ isDate

<span id='CLI-method-isDate'>        /**
</span>         * @method isDate
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Date object, `false` otherwise.
         * @param {Object} object The object to test.
         * @return {Boolean}
         */
        isDate: function(value) {
            return toString.call(value) === &#39;[object Date]&#39;;
        },

        // }}}
        // {{{ isEmpty

<span id='CLI-method-isEmpty'>        /**
</span>         * @method isEmpty
         * @member CLI
         * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:
         *
         * - `null`
         * - `undefined`
         * - a zero-length array
         * - a zero-length string (Unless the `allowEmptyString` parameter is set to `true`)
         *
         * @param {Object} value The value to test.
         * @param {Boolean} [allowEmptyString=false] `true` to allow empty strings.
         * @return {Boolean}
         */
        isEmpty: function(value, allowEmptyString) {
            return (value == null) || (!allowEmptyString ? value === &#39;&#39; : false) || (CLI.isArray(value) &amp;&amp; value.length === 0);
        },

        // }}}
        // {{{ isMSDate

<span id='CLI-method-isMSDate'>        /**
</span>         * @method isMSDate
         * @member CLI
         * Returns &#39;true&#39; if the passed value is a String that matches the MS Date JSON
         * encoding format.
         * @param {String} value The string to test.
         * @return {Boolean}
         */
        isMSDate: function(value) {

            if (!CLI.isString(value)) {
                return false;
            }

            return MSDateRe.test(value);
        },

        // }}}
        // {{{ isObject

<span id='CLI-method-isObject'>        /**
</span>         * @method isObject
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Object, `false` otherwise.
         * @param {Object} value The value to test.
         * @return {Boolean}
         * @method
         */
        isObject: function(value) {
            return toString.call(value) === &#39;[object Object]&#39;;
        },

        // }}}
        // {{{ isPrimitive

<span id='CLI-method-isPrimitive'>        /**
</span>         * @method isPrimitive
         * @member CLI
         * Returns `true` if the passed value is a JavaScript &#39;primitive&#39;, a string, number
         * or boolean.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isPrimitive: function(value) {

            var type = typeof value;

            return type === &#39;string&#39; || type === &#39;number&#39; || type === &#39;boolean&#39;;
        },

        // }}}
        // {{{ isFunction

<span id='CLI-method-isFunction'>        /**
</span>         * @method isFunction
         * @member CLI
         * Returns `true` if the passed value is a JavaScript Function, `false` otherwise.
         * @param {Object} value The value to test.
         * @return {Boolean}
         * @method
         */
        isFunction: function(value) {
            return !!value &amp;&amp; typeof value === &#39;function&#39;;
        },

        // }}}
        // {{{ isNumber

<span id='CLI-method-isNumber'>        /**
</span>         * @method isNumber
         * @member CLI
         * Returns `true` if the passed value is a number. Returns `false` for non-finite numbers.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isNumber: function(value) {
            return typeof value === &#39;number&#39; &amp;&amp; isFinite(value);
        },

        // }}}
        // {{{ isNumeric

<span id='CLI-method-isNumeric'>        /**
</span>         * @method isNumeric
         * @member CLI
         * Validates that a value is numeric.
         * @param {Object} value Examples: 1, &#39;1&#39;, &#39;2.34&#39;
         * @return {Boolean} True if numeric, false otherwise
         */
        isNumeric: function(value) {
            return !isNaN(parseFloat(value)) &amp;&amp; isFinite(value);
        },

        // }}}
        // {{{ isString

<span id='CLI-method-isString'>        /**
</span>         * @method isString
         * @member CLI
         * Returns `true `if the passed value is a string.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isString: function(value) {
            return typeof value === &#39;string&#39;;
        },

        // }}}
        // {{{ isBoolean

<span id='CLI-method-isBoolean'>        /**
</span>         * @method isBoolean
         * @member CLI
         * Returns `true` if the passed value is a boolean.
         *
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isBoolean: function(value) {
            return typeof value === &#39;boolean&#39;;
        },

        // }}}
        // {{{ isDefined

<span id='CLI-method-isDefined'>        /**
</span>         * @method isDefined
         * @member CLI
         * Returns `true` if the passed value is defined.
         * @param {Object} value The value to test.
         * @return {Boolean}
         */
        isDefined: function(value) {
            return typeof value !== &#39;undefined&#39;;
        },

        // }}}
        // {{{ isIterable

<span id='CLI-method-isIterable'>        /**
</span>         * @method isIterable
         * @member CLI
         * Returns `true` if the passed value is iterable, that is, if elements of it are addressable using array
         * notation with numeric indices, `false` otherwise.
         *
         * Arrays and function `arguments` objects are iterable. Also HTML collections such as `NodeList` and `HTMLCollection&#39;
         * are iterable.
         *
         * @param {Object} value The value to test
         * @return {Boolean}
         */
        isIterable: function(value) {

            if (!value || typeof value.length !== &#39;number&#39; || typeof value === &#39;string&#39; || CLI.isFunction(value)) {
                return false;
            }

            if (value.hasOwnProperty(&#39;length&#39;) &amp;&amp; !value.propertyIsEnumerable(&#39;length&#39;)) {
                return true;
            }

            return iterableRe.test(toString.call(value));
        },

        // }}}
        // {{{ now

<span id='CLI-method-now'>        /**
</span>         * @method now
         * @member CLI
         * Returns the current timestamp.
         * @return {Number} Milliseconds since UNIX epoch.
         * @method
         */
        now: Date.now,

        // }}}
        // {{{ functionFactory

<span id='global-method-functionFactory'>        /**
</span>         * @private
         */
        functionFactory: function() {

            var args = Array.prototype.slice.call(arguments),
                ln;

            return Function.prototype.constructor.apply(Function.prototype, args);
        },

        // }}}
        // {{{ valueFrom

<span id='CLI-method-valueFrom'>        /**
</span>         * @method valueFrom
         * @member CLI
         * Returns the given value itself if it&#39;s not empty, as described in {@link CLI#isEmpty}; returns the default
         * value (second argument) otherwise.
         *
         * @param {Object} value The value to test.
         * @param {Object} defaultValue The value to return if the original value is empty.
         * @param {Boolean} [allowBlank=false] `true` to allow zero length strings to qualify as non-empty.
         * @return {Object} value, if non-empty, else defaultValue.
         */
        valueFrom: function(value, defaultValue, allowBlank){
            return CLI.isEmpty(value, allowBlank) ? defaultValue : value;
        },

        // }}}
        // {{{ override

<span id='CLI-method-override'>        /**
</span>         * Overrides members of the specified `target` with the given values.
         *
         * If the `target` is a class declared using {@link CLI#define CLI.define}, the
         * `override` method of that class is called (see {@link CLI.Base#override}) given
         * the `overrides`.
         *
         * If the `target` is a function, it is assumed to be a constructor and the contents
         * of `overrides` are applied to its `prototype` using {@link CLI#apply CLI.apply}.
         *
         * If the `target` is an instance of a class declared using {@link CLI#define CLI.define},
         * the `overrides` are applied to only that instance. In this case, methods are
         * specially processed to allow them to use {@link CLI.Base#callParent}.
         *
         *      var panel = new CLI.Panel({ ... });
         *
         *      CLI.override(panel, {
         *          initComponent: function () {
         *              // extra processing...
         *
         *              this.callParent();
         *          }
         *      });
         *
         * If the `target` is none of these, the `overrides` are applied to the `target`
         * using {@link CLI#apply CLI.apply}.
         *
         * Please refer to {@link CLI#define CLI.define} and {@link CLI.Base#override} for
         * further details.
         *
         * @param {Object} target The target to override.
         * @param {Object} overrides The properties to add or replace on `target`.
         * @method override
         * @member CLI
         */
        override: function (target, overrides) {

            if (target.$isClass) {

                target.override(overrides);

            } else if (typeof target == &#39;function&#39;) {

                CLI.apply(target.prototype, overrides);

            } else {

                var owner = target.self,
                    name, value;

                if (owner &amp;&amp; owner.$isClass) { // if (instance of CLI.define&#39;d class)

                    for (name in overrides) {

                        if (overrides.hasOwnProperty(name)) {

                            value = overrides[name];

                            if (typeof value === &#39;function&#39;) {

                                if (owner.$className) {
                                    value.displayName = owner.$className + &#39;#&#39; + name;
                                }

                                value.$name = name;
                                value.$owner = owner;
                                value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
                            }

                            target[name] = value;
                        }
                    }

                } else {

                    CLI.apply(target, overrides);

                }

            }

            return target;
        },

        // }}}
        // {{{ clone

<span id='CLI-method-clone'>        /**
</span>         * @method clone
         * @member CLI
         * Clone simple variables including array, {}-like objects, DOM nodes and Date without keeping the old reference.
         * A reference for the object itself is returned if it&#39;s not a direct decendant of Object. For model cloning,
         * see {@link CLI.data.Model#copy Model.copy}.
         *
         * @param {Object} item The variable to clone
         * @return {Object} clone
         */
        clone: function(item) {

            if (item === null || item === undefined) {
                return item;
            }

            var type = toString.call(item),
                i, j, k, clone, key;

            // Date
            if (type === &#39;[object Date]&#39;) {
                return new Date(item.getTime());
            }

            // Array
            if (type === &#39;[object Array]&#39;) {
                i = item.length;

                clone = [];

                while (i--) {
                    clone[i] = CLI.clone(item[i]);
                }
            }

            // Object
            else if (type === &#39;[object Object]&#39; &amp;&amp; item.constructor === Object) {

                clone = {};

                for (key in item) {
                    clone[key] = CLI.clone(item[key]);
                }

            }

            return clone || item;
        },

        // }}}
        // {{{ typeOf

<span id='CLI-method-typeOf'>        /**
</span>         * @method typeOf
         * @member CLI
         * Returns the type of the given variable in string format. List of possible values are:
         *
         * - `undefined`: If the given value is `undefined`
         * - `null`: If the given value is `null`
         * - `string`: If the given value is a string
         * - `number`: If the given value is a number
         * - `boolean`: If the given value is a boolean value
         * - `date`: If the given value is a `Date` object
         * - `function`: If the given value is a function reference
         * - `object`: If the given value is an object
         * - `array`: If the given value is an array
         * - `regexp`: If the given value is a regular expression
         *
         * @param {Object} value
         * @return {String}
         */
        typeOf: (function () {

            var nonWhitespaceRe = /\S/,
                toString = Object.prototype.toString,
                typeofTypes = {
                    number: 1,
                    string: 1,
                    &#39;boolean&#39;: 1,
                    &#39;undefined&#39;: 1
                },
                toStringTypes = {
                    &#39;[object Array]&#39;  : &#39;array&#39;,
                    &#39;[object Date]&#39;   : &#39;date&#39;,
                    &#39;[object Boolean]&#39;: &#39;boolean&#39;,
                    &#39;[object Number]&#39; : &#39;number&#39;,
                    &#39;[object RegExp]&#39; : &#39;regexp&#39;
                };

            return function(value) {

                if (value === null) {
                    return &#39;null&#39;;
                }

                var type = typeof value,
                    ret, typeToString;

                if (typeofTypes[type]) {
                    return type;
                }

                ret = toStringTypes[typeToString = toString.call(value)];

                if (ret) {
                    return ret;
                }

                if (type === &#39;function&#39;) {
                    return &#39;function&#39;;
                }

                if (type === &#39;object&#39;) {
                    return &#39;object&#39;;
                }

                // TODO: implemented after, enable
                /*
                CLI.Error.raise({
                    sourceClass: &#39;CLI&#39;,
                    sourceMethod: &#39;typeOf&#39;,
                    msg: &#39;Failed to determine the type of &quot;&#39; + value + &#39;&quot;.&#39;
                });
               */

                return typeToString;
            };

        }()),

        // }}}
        // {{{ log

<span id='CLI-method-log'>        /**
</span>         * @method log
         * @member CLI
         * Logs a message. If a console is present it will be used. On Opera, the method
         * &quot;opera.postError&quot; is called. In other cases, the message is logged to an array
         * &quot;CLI.log.out&quot;. An attached debugger can watch this array and view the log. The
         * log buffer is limited to a maximum of &quot;CLI.log.max&quot; entries (defaults to 250).
         *
         * If additional parameters are passed, they are joined and appended to the message.
         * A technique for tracing entry and exit of a function is this:
         *
         *     function foo () {
         *         CLI.log({ indent: 1 }, &#39;&gt;&gt; foo&#39;);
         *
         *         // log statements in here or methods called from here will be indented
         *         // by one step
         *
         *         CLI.log({ outdent: 1 }, &#39;&lt;&lt; foo&#39;);
         *     }
         *
         * This method does nothing in a release build.
         *
         * @param {String/Object} [options] The message to log or an options object with any
         * of the following properties:
         *
         *  - `msg`: The message to log (required).
         *  - `level`: One of: &quot;error&quot;, &quot;warn&quot;, &quot;info&quot; or &quot;log&quot; (the default is &quot;log&quot;).
         *  - `dump`: An object to dump to the log as part of the message.
         *  - `stack`: True to include a stack trace in the log.
         *  - `indent`: Cause subsequent log statements to be indented one step.
         *  - `outdent`: Cause this and following statements to be one step less indented.
         *
         * @param {String...} [message] The message to log (required unless specified in
         * options object).
         */
        log:
            (function () {
            /*
             * Iterate through an object to dump its content into a string.
             * For example:
             *     {
             *         style: {
             *             lineWidth: 1
             *         },
             *         label: {},
             *         marker: {
             *             strokeStyle: &quot;#555&quot;,
             *             radius: 3,
             *             size: 3
             *         },
             *         subStyle: {
             *             fillStyle: [
             *                 0: &quot;#133987&quot;,
             *                 1: &quot;#1c55ca&quot;,
             *                 2: &quot;#4d7fe6&quot;
             *             ]
             *         },
             *         markerSubStyle: {}
             *     } 
             *
             * @param {Object} object The object to iterate
             * @param {Number} [level] Current level of identation (and recursion). Default is 0.
             * @param {Number} [maxLevel] Maximum level of recursion. Default is 3.
             * @param {Boolean} [withFunctions] Include functions in the output.
             * @return {String} The string with the contents of the object
             */
            var primitiveRe = /string|number|boolean/;

            function dumpObject(object, level, maxLevel, withFunctions) {

                var member, type, value, name, prefix, suffix,
                    members = [];

                if (CLI.isArray(object)) {

                    prefix = &#39;[&#39;;
                    suffix = &#39;]&#39;;

                } else if (CLI.isObject(object)) {

                    prefix = &#39;{&#39;;
                    suffix = &#39;}&#39;;

                }

                if (!maxLevel) {
                    maxLevel = 3;
                }

                if (level &gt; maxLevel) {
                    return prefix+&#39;...&#39;+suffix;
                }

                level = level || 1;

                var spacer = (new Array(level)).join(&#39;    &#39;);

                // Cannot use CLI.encode since it can recurse endlessly
                for (name in object) {

                    if (object.hasOwnProperty(name)) {

                        value = object[name];

                        type = typeof value;

                        if (type == &#39;function&#39;) {

                            if (!withFunctions) {
                                continue;
                            }

                            member = type;

                        } else if (type == &#39;undefined&#39;) {

                            member = type;

                        } else if (value === null || primitiveRe.test(type) || CLI.isDate(value)) {

                            member = CLI.encode(value);

                        } else if (CLI.isArray(value)) {

                            member = this.dumpObject(value, level+1, maxLevel, withFunctions);

                        } else if (CLI.isObject(value)) {

                            member = this.dumpObject(value, level+1, maxLevel, withFunctions);

                        } else {

                            member = type;

                        }

                        members.push(spacer + name + &#39;: &#39; + member);    // or CLI.encode(name)
                    }
                }

                if (members.length) {

                    return prefix + &#39;\n    &#39;+ members.join(&#39;,\n    &#39;) + &#39;\n&#39;+spacer+suffix;

                }

                return prefix+suffix;

            }

            // {{{ log

            function log(message) {

                var options, dump,
                    con = CLI.global.console,
                    level = &#39;log&#39;,
                    indent = log.indent || 0,
                    stack,
                    out,
                    max;

                log.indent = indent;

                if (typeof message != &#39;string&#39;) {

                    options = message;
                    message = options.msg || &#39;&#39;;
                    level = options.level || level;
                    dump = options.dump;
                    stack = options.stack;

                    if (options.indent) {

                        ++log.indent;

                    } else if (options.outdent) {

                        log.indent = indent = Math.max(indent - 1, 0);

                    }

                    if (dump &amp;&amp; !(con &amp;&amp; con.dir)) {

                        message += dumpObject(dump);
                        dump = null;

                    }

                }

                if (arguments.length &gt; 1) {

                    message += Array.prototype.slice.call(arguments, 1).join(&#39;&#39;);

                }

                message = indent ? CLI.String.repeat(&#39; &#39;, log.indentSize * indent) + message : message;
                // w/o console, all messages are equal, so munge the level into the message:

                if (level != &#39;log&#39;) {
                    message = &#39;[&#39; + level.charAt(0).toUpperCase() + &#39;] &#39; + message;
                }

                if (con[level]) {

                    if (con.suspended !== true) {
                        con[level](message);
                    }

                } else {

                    if (con.suspended !== true) {
                        con.log(message);
                    }

                }

                if (dump) {

                    if (con.suspended !== true) {
                        con.dir(dump);
                    }

                }

                if (stack &amp;&amp; con.trace) {

                    if (con.suspended !== true) {

                        if (level != &#39;error&#39;) {
                            con.trace();
                        }

                    }
                }

                if (con.suspended !== true) {

                    // Mostly informational, but the CLI.Error notifier uses them:
                    ++log.count;
                    ++log.counters[level];

                }
            }

            // }}}
            // {{{ logx

            function logx(level, args) {

                if (typeof args[0] == &#39;string&#39;) {
                    args.unshift({});
                }

                args[0].level = level;
                log.apply(this, args);
            }

            // }}}

            log.error = function () {

                if (CLI.global.console.suspended !== true) {
                    logx(&#39;error&#39;, Array.prototype.slice.call(arguments));
                }

            };

            log.info = function () {

                if (CLI.global.console.suspended !== true) {
                    logx(&#39;info&#39;, Array.prototype.slice.call(arguments));
                }

            };

            log.warn = function () {

                if (CLI.global.console.suspended !== true) {
                    logx(&#39;warn&#39;, Array.prototype.slice.call(arguments));
                }

            };

            log.count = 0;
            log.counters = { error: 0, warn: 0, info: 0, log: 0 };
            log.indentSize = 2;
            log.out = [];
            log.max = 750;

            return log;

        }())

        // }}}

    });

})();

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
