<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/*!
 * This file is part of CLI Framework
 */

<span id='CLI-Class'>/**
</span> * @class CLI.Class
 *
 * Handles class creation throughout the framework. This is a low level factory that is used by CLI.ClassManager and generally
 * should not be used directly. If you choose to use CLI.Class you will lose out on the namespace, aliasing and depency loading
 * features made available by CLI.ClassManager. The only time you would use CLI.Class directly is to create an anonymous class.
 *
 * If you wish to create a class you should use {@link CLI#define CLI.define} which aliases
 * {@link CLI.ClassManager#create CLI.ClassManager.create} to enable namespacing and dynamic dependency resolution.
 *
 * CLI.Class is the factory and **not** the superclass of everything. For the base class that **all** CLI classes inherit
 * from, see {@link CLI.Base}.
 * @private
 */

(function() {

    &quot;use strict&quot;;
    (function() {
        // @define CLI.Class
        var CLIClass,
            Base = CLI.Base,
            baseStaticMembers = Base.$staticMembers;

        // {{{ makeCtor

        // Creates a constructor that has nothing extra in its scope chain.
        function makeCtor (className) {

            function constructor () {

                // Opera has some problems returning from a constructor when Dragonfly isn&#39;t running. The || null seems to
                // be sufficient to stop it misbehaving. Known to be required against 10.53, 11.51 and 11.61.
                return this.constructor.apply(this, arguments) || null;

            }

            if (className) {
                constructor.displayName = className;
            }

            return constructor;
        }

        // }}}

        CLI.Class = CLIClass = function(Class, data, onCreated) {

            if (typeof Class != &#39;function&#39;) {

                onCreated   = data;
                data        = Class;
                Class       = null;

            }

            if (!data) {
                data = {};
            }

            Class = CLIClass.create(Class, data);

            CLIClass.process(Class, data, onCreated);

            return Class;
        };

        CLI.apply(CLIClass, {

            // {{{ makeCtor

            makeCtor: makeCtor,

            // }}}
            // {{{ onBeforeCreated

<span id='CLI-Class-method-onBeforeCreated'>            /**
</span>             * @private
             */
            onBeforeCreated: function(Class, data, hooks) {

                CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;&gt;&gt; CLI.Class#onBeforeCreated&#39;, arguments);

                Class.addMembers(data);

                hooks.onCreated.call(Class, Class);

                CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;&lt;&lt; CLI.Class#onBeforeCreated&#39;, arguments);
            },

            // }}}
            // {{{ create

<span id='CLI-Class-method-create'>            /**
</span>             * @private
             */
            create: function (Class, data) {

                var i = baseStaticMembers.length,
                    name;

                if (!Class) {

                    Class = makeCtor(
                        data.$className
                    );

                }

                while (i--) {
                    name = baseStaticMembers[i];
                    Class[name] = Base[name];
                }

                return Class;
            },

            // }}}
            // {{{ process

<span id='CLI-Class-method-process'>            /**
</span>             * @private
             */
            process: function(Class, data, onCreated) {

                var preprocessorStack = data.preprocessors || CLIClass.defaultPreprocessors,
                    registeredPreprocessors = this.preprocessors,
                    hooks = {
                        onBeforeCreated: this.onBeforeCreated
                    },
                    preprocessors = [],
                    preprocessor, preprocessorsProperties,
                    i, ln, j, subLn, preprocessorProperty;

                delete data.preprocessors;
                Class._classHooks = hooks;

                for (i = 0,ln = preprocessorStack.length; i &lt; ln; i++) {

                    preprocessor = preprocessorStack[i];

                    if (typeof preprocessor == &#39;string&#39;) {

                        preprocessor = registeredPreprocessors[preprocessor];
                        preprocessorsProperties = preprocessor.properties;

                        if (preprocessorsProperties === true) {

                            preprocessors.push(preprocessor.fn);

                        } else if (preprocessorsProperties) {

                            for (j = 0,subLn = preprocessorsProperties.length; j &lt; subLn; j++) {

                                preprocessorProperty = preprocessorsProperties[j];

                                if (data.hasOwnProperty(preprocessorProperty)) {

                                    preprocessors.push(preprocessor.fn);
                                    break;

                                }

                            }

                        }

                    } else {

                        preprocessors.push(preprocessor);

                    }
                }

                hooks.onCreated = onCreated ? onCreated : CLI.emptyFn;
                hooks.preprocessors = preprocessors;

                this.doProcess(Class, data, hooks);
            },

            // }}}
            // {{{ doProcess

<span id='CLI-Class-method-doProcess'>            /**
</span>             * @private
             */
            doProcess: function(Class, data, hooks) {

                var me = this,
                    preprocessors = hooks.preprocessors,
                    preprocessor = preprocessors.shift(),
                    doProcess = me.doProcess;

                for ( ; preprocessor ; preprocessor = preprocessors.shift()) {

                    // Returning false signifies an asynchronous preprocessor - it will call doProcess when we can continue
                    if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
                        return;
                    }

                }

                hooks.onBeforeCreated.apply(me, arguments);
            },

            // }}}
            // {{{ preprocessors

<span id='CLI-Class-property-preprocessors'>            /**
</span>             * @private
             */
            preprocessors: {},

            // }}}
            // {{{ registerPreprocessor

<span id='CLI-Class-static-method-registerPreprocessor'>            /**
</span>             * Register a new pre-processor to be used during the class creation process
             *
             * @param {String} name The pre-processor&#39;s name
             * @param {Function} fn The callback function to be executed. Typical format:
             *
             *     function(cls, data, fn) {
             *         // Your code here
             *
             *         // Execute this when the processing is finished.
             *         // Asynchronous processing is perfectly ok
             *         if (fn) {
             *             fn.call(this, cls, data);
             *         }
             *     });
             *
             * @param {Function} fn.cls The created class
             * @param {Object} fn.data The set of properties passed in {@link CLI.Class} constructor
             * @param {Function} fn.fn The callback function that **must** to be executed when this
             * pre-processor finishes, regardless of whether the processing is synchronous or aynchronous.
             * @return {CLI.Class} this
             * @private
             * @static
             */
            registerPreprocessor: function(name, fn, properties, position, relativeTo) {

                if (!position) {
                    position = &#39;last&#39;;
                }

                if (!properties) {
                    properties = [name];
                }

                this.preprocessors[name] = {
                    name: name,
                    properties: properties || false,
                    fn: fn
                };

                this.setDefaultPreprocessorPosition(name, position, relativeTo);

                return this;
            },

            // }}}
            // {{{ getPreprocessor

<span id='CLI-Class-static-method-getPreprocessor'>            /**
</span>             * Retrieve a pre-processor callback function by its name, which has been registered before
             *
             * @param {String} name
             * @return {Function} preprocessor
             * @private
             * @static
             */
            getPreprocessor: function(name) {
                return this.preprocessors[name];
            },

            // }}}
            // {{{ getPreprocessors

<span id='CLI-Class-method-getPreprocessors'>            /**
</span>             * @private
             */
            getPreprocessors: function() {
                return this.preprocessors;
            },

            // }}}
            // {{{ defaultPreprocessors

<span id='CLI-Class-property-defaultPreprocessors'>            /**
</span>             * @private
             */
            defaultPreprocessors: [],

            // }}}
            // {{{ getDefaultPreprocessors

<span id='CLI-Class-static-method-getDefaultPreprocessors'>            /**
</span>             * Retrieve the array stack of default pre-processors
             * @return {Function[]} defaultPreprocessors
             * @private
             * @static
             */
            getDefaultPreprocessors: function() {
                return this.defaultPreprocessors;
            },

            // }}}
            // {{{ setDefaultPreprocessors

<span id='CLI-Class-static-method-setDefaultPreprocessors'>            /**
</span>             * Set the default array stack of default pre-processors
             *
             * @private
             * @param {Array} preprocessors
             * @return {CLI.Class} this
             * @static
             */
            setDefaultPreprocessors: function(preprocessors) {
                this.defaultPreprocessors = CLI.Array.from(preprocessors);

                return this;
            },

            // }}}
            // {{{ setDefaultPreprocessorPosition

<span id='CLI-Class-static-method-setDefaultPreprocessorPosition'>            /**
</span>             * Insert this pre-processor at a specific position in the stack, optionally relative to
             * any existing pre-processor. For example:
             *
             *     CLI.Class.registerPreprocessor(&#39;debug&#39;, function(cls, data, fn) {
             *         // Your code here
             *
             *         if (fn) {
             *             fn.call(this, cls, data);
             *         }
             *     }).setDefaultPreprocessorPosition(&#39;debug&#39;, &#39;last&#39;);
             *
             * @private
             * @param {String} name The pre-processor name. Note that it needs to be registered with
             * {@link CLI.Class#registerPreprocessor registerPreprocessor} before this
             * @param {String} offset The insertion position. Four possible values are:
             * &#39;first&#39;, &#39;last&#39;, or: &#39;before&#39;, &#39;after&#39; (relative to the name provided in the third argument)
             * @param {String} relativeName
             * @return {CLI.Class} this
             * @static
             */
            setDefaultPreprocessorPosition: function(name, offset, relativeName) {

                var defaultPreprocessors = this.defaultPreprocessors,
                    index;

                if (typeof offset == &#39;string&#39;) {

                    if (offset === &#39;first&#39;) {

                        defaultPreprocessors.unshift(name);

                        return this;

                    } else if (offset === &#39;last&#39;) {

                        defaultPreprocessors.push(name);

                        return this;
                    }

                    offset = (offset === &#39;after&#39;) ? 1 : -1;
                }

                index = CLI.Array.indexOf(defaultPreprocessors, relativeName);

                if (index !== -1) {
                    CLI.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
                }

                return this;
            }

            // }}}

        });

<span id='CLI-Class-cfg-extend'>        /**
</span>         * @cfg {String} extend
         * The parent class that this class extends. For example:
         *
         *     CLI.define(&#39;Person&#39;, {
         *         say: function(text) { alert(text); }
         *     });
         *
         *     CLI.define(&#39;Developer&#39;, {
         *         extend: &#39;Person&#39;,
         *         say: function(text) { this.callParent([&quot;print &quot;+text]); }
         *     });
         */
        CLIClass.registerPreprocessor(&#39;extend&#39;, function(Class, data, hooks) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#extendPreProcessor&#39;, arguments);

            var Base = CLI.Base,
                basePrototype = Base.prototype,
                extend = data.extend,
                Parent, parentPrototype, i;

            delete data.extend;

            if (extend &amp;&amp; extend !== Object) {

                Parent = extend;

            } else {

                Parent = Base;

            }

            parentPrototype = Parent.prototype;

            if (!Parent.$isClass) {
                for (i in basePrototype) {
                    if (!parentPrototype[i]) {
                        parentPrototype[i] = basePrototype[i];
                    }
                }
            }

            Class.extend(Parent);

            Class.triggerExtended.apply(Class, arguments);

            if (data.onClassExtended) {

                Class.onExtended(data.onClassExtended, Class);
                delete data.onClassExtended;

            }

        }, true); // true to always run this preprocessor even w/o &quot;extend&quot; keyword

        CLIClass.registerPreprocessor(&#39;privates&#39;, function(Class, data) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#privatePreprocessor&#39;, arguments);

            var privates = data.privates,
                statics = privates.statics,
                privacy = privates.privacy || true;

            delete data.privates;
            delete privates.statics;

            // We have to add this preprocessor so that private getters/setters are picked up
            // by the config system. This also catches duplication in the public part of the
            // class since it is an error to override a private method with a public one.
            Class.addMembers(privates, false, privacy);

            if (statics) {
                Class.addMembers(statics, true, privacy);
            }

        });

<span id='CLI-Class-cfg-statics'>        /**
</span>         * @cfg {Object} statics
         * List of static methods for this class. For example:
         *
         *     CLI.define(&#39;Computer&#39;, {
         *          statics: {
         *              factory: function(brand) {
         *                  // &#39;this&#39; in static methods refer to the class itself
         *                  return new this(brand);
         *              }
         *          },
         *
         *          constructor: function() { ... }
         *     });
         *
         *     var dellComputer = Computer.factory(&#39;Dell&#39;);
         */
        CLIClass.registerPreprocessor(&#39;statics&#39;, function(Class, data) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#staticsPreprocessor&#39;, arguments);

            Class.addStatics(data.statics);

            delete data.statics;
        });

<span id='CLI-Class-cfg-inheritableStatics'>        /**
</span>         * @cfg {Object} inheritableStatics
         * List of inheritable static methods for this class.
         * Otherwise just like {@link #statics} but subclasses inherit these methods.
         */
        CLIClass.registerPreprocessor(&#39;inheritableStatics&#39;, function(Class, data) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#inheritableStaticsPreprocessor&#39;, arguments);

            Class.addInheritableStatics(data.inheritableStatics);

            delete data.inheritableStatics;
        });

<span id='CLI-Class-cfg-platformConfig'>        /**
</span>         * @cfg {Object} platformConfig
         * Allows for setting default config values on specific platforms or themes
         *
         *     CLI.define(&#39;MyComponent&#39;, {
         *          config: {
         *              top: 0
         *          },
         *
         *          platformConfig: [{
         *              platform: [&#39;ie10&#39;],
         *              theme: [&#39;Windows&#39;],
         *              top: null,
         *              bottom: 0
         *          }]
         *     });
         */
        CLIClass.registerPreprocessor(&#39;platformConfig&#39;, function(Class, data, hooks) {

            var platformConfigs = data.platformConfig,
                config = data.config || {},
                themeName = CLI.theme || (CLI.theme = {
                    name: &#39;Default&#39;
                }),
                platform, theme, platformConfig, i, ln, j , ln2;

            delete data.platformConfig;
            themeName = themeName &amp;&amp; themeName.name;

            for (i = 0, ln = platformConfigs.length; i &lt; ln; i++) {
                platformConfig = platformConfigs[i];

                platform = platformConfig.platform;
                delete platformConfig.platform;

                theme = [].concat(platformConfig.theme);
                ln2 = theme.length;
                delete platformConfig.theme;

                if (ln2) {

                    for (j = 0; j &lt; ln2; j++) {

                        if (CLI.theme.name == theme[j]) {

                            CLI.merge(config, platformConfig);

                        }

                    }

                }

            }

        });

<span id='CLI-Class-cfg-config'>        /**
</span>         * @cfg {Object} config
         *
         * List of configuration options with their default values.
         *
         * __Note:__ You need to make sure {@link CLI.Base#initConfig} is called from your constructor if you are defining
         * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
         * methods will not be initialized.
         *
         * Each config item will have its own setter and getter method automatically generated inside the class prototype
         * during class creation time, if the class does not have those methods explicitly defined.
         *
         * As an example, let&#39;s convert the name property of a Person class to be a config item, then add extra age and
         * gender items.
         *
         *     CLI.define(&#39;My.sample.Person&#39;, {
         *         config: {
         *             name: &#39;Mr. Unknown&#39;,
         *             age: 0,
         *             gender: &#39;Male&#39;
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *
         *             return this;
         *         }
         *
         *         // ...
         *     });
         *
         * Within the class, this.name still has the default value of &quot;Mr. Unknown&quot;. However, it&#39;s now publicly accessible
         * without sacrificing encapsulation, via setter and getter methods.
         *
         *     var jacky = new Person({
         *         name: &quot;Jacky&quot;,
         *         age: 35
         *     });
         *
         *     alert(jacky.getAge());      // alerts 35
         *     alert(jacky.getGender());   // alerts &quot;Male&quot;
         *
         *     jacky.walk(10);             // alerts &quot;Jacky is walking 10 steps&quot;
         *
         *     jacky.setName(&quot;Mr. Nguyen&quot;);
         *     alert(jacky.getName());     // alerts &quot;Mr. Nguyen&quot;
         *
         *     jacky.walk(10);             // alerts &quot;Mr. Nguyen is walking 10 steps&quot;
         *
         * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
         * Two key things happened:
         *
         *  - The provided config object when the class is instantiated is recursively merged with the default config object.
         *  - All corresponding setter methods are called with the merged values.
         *
         * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
         *
         *  - Filtering / validation / transformation of the given value before it&#39;s actually stored within the instance.
         *  - Notification (such as firing events) / post-processing after the value has been set, or changed from a
         *    previous value.
         *
         * By standardize this common pattern, the default generated setters provide two extra template methods that you
         * can put your own custom logics into, i.e: an &quot;applyFoo&quot; and &quot;updateFoo&quot; method for a &quot;foo&quot; config item, which are
         * executed before and after the value is actually set, respectively. Back to the example class, let&#39;s validate that
         * age must be a valid positive number, and fire an &#39;agechange&#39; if the value is modified.
         *
         *     CLI.define(&#39;My.sample.Person&#39;, {
         *         config: {
         *             // ...
         *         },
         *
         *         constructor: {
         *             // ...
         *         },
         *
         *         applyAge: function(age) {
         *             if (typeof age !== &#39;number&#39; || age &lt; 0) {
         *                 console.warn(&quot;Invalid age, must be a positive number&quot;);
         *                 return;
         *             }
         *
         *             return age;
         *         },
         *
         *         updateAge: function(newAge, oldAge) {
         *             // age has changed from &quot;oldAge&quot; to &quot;newAge&quot;
         *             this.fireEvent(&#39;agechange&#39;, this, newAge, oldAge);
         *         }
         *
         *         // ...
         *     });
         *
         *     var jacky = new Person({
         *         name: &quot;Jacky&quot;,
         *         age: &#39;invalid&#39;
         *     });
         *
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(-100));  // alerts 0
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(35));    // alerts 0
         *     alert(jacky.getAge());      // alerts 35
         *
         * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
         * explicitly. Instead, &quot;apply*&quot; and &quot;update*&quot; methods should be implemented where necessary. Your code will be
         * consistent throughout and only contain the minimal logic that you actually care about.
         *
         * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
         * the child&#39;s default config. The same applies for mixins.
         */
        CLIClass.registerPreprocessor(&#39;config&#39;, function(Class, data) {

            // Need to copy to the prototype here because that happens after preprocessors
            if (data.hasOwnProperty(&#39;$configPrefixed&#39;)) {

                Class.prototype.$configPrefixed = data.$configPrefixed;

            }

            Class.addConfig(data.config);

            // We need to remove this or it will be applied by addMembers and smash the
            // &quot;config&quot; placed on the prototype by Configurator (which includes *all* configs
            // such as cachedConfigs).
            delete data.config;

        });

<span id='CLI-Class-cfg-cachedConfig'>        /**
</span>         * @cfg {Object} cachedConfig
         * 
         * This configuration works in a very similar manner to the {@link #config} option.
         * The difference is that the configurations are only ever processed when the first instance
         * of that class is created. The processed value is then stored on the class prototype and
         * will not be processed on subsequent instances of the class. Getters/setters will be generated
         * in exactly the same way as {@link #config}.
         * 
         * This option is useful for expensive objects that can be shared across class instances. 
         * The class itself ensures that the creation only occurs once.
         */
        CLIClass.registerPreprocessor(&#39;cachedConfig&#39;, function(Class, data) {

            // Need to copy to the prototype here because that happens after preprocessors
            if (data.hasOwnProperty(&#39;$configPrefixed&#39;)) {
                Class.prototype.$configPrefixed = data.$configPrefixed;
            }

            Class.addCachedConfig(data.cachedConfig);

            // Remove this so it won&#39;t be placed on the prototype.
            delete data.cachedConfig;
        });

<span id='CLI-Class-cfg-mixins'>        /**
</span>         * @cfg {String[]/Object} mixins
         * List of classes to mix into this class. For example:
         *
         *     CLI.define(&#39;CanSing&#39;, {
         *          sing: function() {
         *              alert(&quot;For he&#39;s a jolly good fellow...&quot;)
         *          }
         *     });
         *
         *     CLI.define(&#39;Musician&#39;, {
         *          mixins: [&#39;CanSing&#39;]
         *     })
         *
         * In this case the Musician class will get a `sing` method from CanSing mixin.
         *
         * But what if the Musician already has a `sing` method? Or you want to mix
         * in two classes, both of which define `sing`?  In such a cases it&#39;s good
         * to define mixins as an object, where you assign a name to each mixin:
         *
         *     CLI.define(&#39;Musician&#39;, {
         *          mixins: {
         *              canSing: &#39;CanSing&#39;
         *          },
         * 
         *          sing: function() {
         *              // delegate singing operation to mixin
         *              this.mixins.canSing.sing.call(this);
         *          }
         *     })
         *
         * In this case the `sing` method of Musician will overwrite the
         * mixed in `sing` method. But you can access the original mixed in method
         * through special `mixins` property.
         */
        CLIClass.registerPreprocessor(&#39;mixins&#39;, function(Class, data, hooks) {

            CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#mixinsPreprocessor&#39;, arguments);

            var mixins = data.mixins,
                onCreated = hooks.onCreated;

            delete data.mixins;

            hooks.onCreated = function() {

                CLI.classSystemMonitor &amp;&amp; CLI.classSystemMonitor(Class, &#39;CLI.Class#mixinsPreprocessor#beforeCreated&#39;, arguments);

                // Put back the original onCreated before processing mixins. This allows a
                // mixin to hook onCreated by access Class._classHooks.
                hooks.onCreated = onCreated;

                Class.mixin(mixins);

                // We must go back to hooks.onCreated here because it may have changed during
                // calls to onClassMixedIn.
                return hooks.onCreated.apply(this, arguments);
            };

        });

    }());

})();

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */
</pre>
</body>
</html>
